//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming



/** Ublux Account */
export interface Account {
    /** Id of document */
    readonly id?: string;
    /** Example, US-1, MX-1
Must have at least one */
    readonly idsCloudServicePbxs?: string[];
    mailingAddress?: MailingAddress;
    accountSecrets?: AccountSecrets;
    /** Name of company */
    companyName?: string;
    /** If client has granted access to support to make changes to account. 
This can only be changed by an ownder of the account. */
    readonly hasGrantedSupportAccess?: boolean;
    /** Countries on this list will not be marked as international calls */
    readonly countriesThatCanCallLocally?: CountryIsoCode[];
    /** If CountriesThatCanCallLocally does not contain country then ublux will attempt to find country on this list. */
    countriesThatCanCallInternationally?: CountryIsoCode[];
    industry?: Industry;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Account secrets */
export interface AccountSecrets {
    /** 9 digit number that used to autoprovision phone. */
    readonly pinPhone?: string;
    /** If you dial *7 and you enter this pin you will be able to ChanSpy "spy" on a extension
9 digits now to make it more secure */
    readonly pinSpy?: string;
}

/** Ublux Account */
export interface AccountUpdateRequest {
    mailingAddress?: MailingAddress;
    accountSecrets?: AccountSecrets;
    /** Name of company */
    companyName?: string | null;
    /** If CountriesThatCanCallLocally does not contain country then ublux will attempt to find country on this list. */
    countriesThatCanCallInternationally?: CountryIsoCode[] | null;
    industry?: Industry;
}

/** Determines how will a call be AI processed. What questions will be asked to the AI engine */
export interface AiCallAnalysisInput {
    /** Id of document */
    readonly id?: string;
    friendlyName?: string;
    description?: string | null;
    /** List of queries to ask AI engine about a call */
    queries?: AiCallAnalysisVariableInput[];
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for AiCallAnalysisInputs */
export interface AiCallAnalysisInputFilterRequest {
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Queries.Query equals */
    queries_query_eq?: string | null;
    /** Queries.Query contains */
    queries_query_con?: string | null;
    /** Queries.Query regex */
    queries_query_reg?: string | null;
    /** Queries.Name equals */
    queries_name_eq?: string | null;
    /** Queries.Name contains */
    queries_name_con?: string | null;
    /** Queries.Name regex */
    queries_name_reg?: string | null;
    /** Queries.AiVariableType equals */
    queries_aiVariableType_eq?: string | null;
    /** Queries.AiVariableType contains */
    queries_aiVariableType_con?: string | null;
    /** Queries.AiVariableType regex */
    queries_aiVariableType_reg?: string | null;
    /** Queries.Value equals */
    queries_value_eq?: string | null;
    /** Queries.Value contains */
    queries_value_con?: string | null;
    /** Queries.Value regex */
    queries_value_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Determines how will a call be AI processed. What questions will be asked to the AI engine */
export interface AiCallAnalysisInputUpdateRequest {
    friendlyName?: string | null;
    description?: string | null;
    /** List of queries to ask AI engine about a call */
    queries?: AiCallAnalysisVariableInput[] | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** AI output of analyzed call */
export interface AiCallAnalysisOutput {
    /** What input was passed to get this output? */
    readonly idAiCallAnalysisInput?: string;
    /** Detected language on call conversation */
    readonly detectedLanguage?: string;
    /** List of queries to ask AI engine about a call */
    readonly output?: AiCallAnalysisVariableOutput[];
    /** Total tokes used by AI engine */
    readonly tokensTotal?: number;
    /** Tokens used by completion on AI engine */
    readonly tokensCompletion?: number;
    /** Tokens used by prompt on AI engine */
    readonly tokensPrompt?: number;
}

/** AI call analysis variable query sent to AI engine */
export interface AiCallAnalysisVariableInput {
    /** Question to ask AI engine about conversation. For example: Client satisfaction with integer value ranging from 1 to 5 */
    query?: string;
    /** There cannot be two variable names with the same name */
    name?: string;
    aiVariableType?: AiVariableType;
    /** Value of variable */
    value?: string | null;
}

/** AI call analysis variable that AI engine outputs */
export interface AiCallAnalysisVariableOutput {
    /** There cannot be two variable names with the same name */
    name?: string;
    aiVariableType?: AiVariableType;
    /** Value of variable */
    value?: string | null;
}

/** AI transcription of a phone call. This is the convertion from audio to text only. */
export interface AiCallTranscription {
    /** Id of document */
    readonly id?: string;
    /** Call being transcribed */
    readonly idCall?: string;
    /** If there is a language it means there is a transcription */
    readonly transcriptionLanguage?: string | null;
    /** Audio of agent converted to text */
    readonly transcription?: AiTranscription[];
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for AiCallTranscriptions */
export interface AiCallTranscriptionFilterRequest {
    /** IdCall equals */
    idCall_eq?: string | null;
    /** IdCall contains */
    idCall_con?: string | null;
    /** IdCall regex */
    idCall_reg?: string | null;
    /** TranscriptionLanguage equals */
    transcriptionLanguage_eq?: string | null;
    /** TranscriptionLanguage contains */
    transcriptionLanguage_con?: string | null;
    /** TranscriptionLanguage regex */
    transcriptionLanguage_reg?: string | null;
    /** Transcription.Speaker equals */
    transcription_speaker_eq?: string | null;
    /** Transcription.Speaker contains */
    transcription_speaker_con?: string | null;
    /** Transcription.Speaker regex */
    transcription_speaker_reg?: string | null;
    /** Transcription.Text equals */
    transcription_text_eq?: string | null;
    /** Transcription.Text contains */
    transcription_text_con?: string | null;
    /** Transcription.Text regex */
    transcription_text_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Converted audio to text */
export interface AiTranscription {
    /** Is it Agent or Client? */
    readonly speaker?: string;
    /** Transcription text */
    readonly text?: string;
    /** Number of seconds when this text was said */
    startTime?: number;
    /** Number of seconds when this text ended being said */
    endTime?: number;
}

/** Type of AI variable */
export enum AiVariableType {
    None = "None",
    Text = "Text",
    Integer = "Integer",
    Decimal = "Decimal",
    Boolean = "Boolean",
    Sentiments = "Sentiments",
    Entities = "Entities",
    Topics = "Topics",
}

/** Provider AirNetworks requests this information for every customer */
export interface AirNetworksCustomerInfo {
    /** The passport number or driver's license number */
    idNumber?: string;
    /** Example Passport or CifNif */
    idType?: string;
    /** This province should be obtained from AirNetworkProvinces table */
    province?: string;
    /** Id of air networks province */
    idAirNetworksProvince?: string;
    /** Population */
    population?: string;
}

export interface AmazonVoice {
    id?: string | null;
    gender?: string | null;
    languageCode?: string | null;
    languageName?: string | null;
}

/** Someone that has access to consume Ublux Web Api. It can be a PBX, WA, or UbluxUser */
export interface ApiKey {
    /** Id of document */
    readonly id?: string;
    /** User that created this key. */
    readonly idUser?: string;
    /** Key = service/role such as Phone. The phone role probably will have access to the PhoneController service
Value = Permissions it has on that role. Maybe it can only read data from that service but it cannot update, create or modify. */
    ubluxRoles?: UbluxRole[];
    /** If null it will never expire. Else it will have an expiration */
    dateExpire?: Date | null;
    /** Date last authenticated */
    readonly dateLastUsed?: Date | null;
    /** Description or notes of API key */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for ApiKeys */
export interface ApiKeyFilterRequest {
    /** IdUser equals */
    idUser_eq?: string | null;
    /** IdUser contains */
    idUser_con?: string | null;
    /** IdUser regex */
    idUser_reg?: string | null;
    ubluxRoles_con?: UbluxRole;
    /** DateExpire equals */
    dateExpire_eq?: Date | null;
    /** DateExpire less than or equal to */
    dateExpire_lte?: Date | null;
    /** DateExpire greater than or equal to */
    dateExpire_gte?: Date | null;
    /** DateLastUsed equals */
    dateLastUsed_eq?: Date | null;
    /** DateLastUsed less than or equal to */
    dateLastUsed_lte?: Date | null;
    /** DateLastUsed greater than or equal to */
    dateLastUsed_gte?: Date | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Someone that has access to consume Ublux Web Api. It can be a PBX, WA, or UbluxUser */
export interface ApiKeyUpdateRequest {
    /** Key = service/role such as Phone. The phone role probably will have access to the PhoneController service
Value = Permissions it has on that role. Maybe it can only read data from that service but it cannot update, create or modify. */
    ubluxRoles?: UbluxRole[] | null;
    /** If null it will never expire. Else it will have an expiration */
    dateExpire?: Date | null;
    /** Description or notes of API key */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Mp3 or Wav audio file. Previously called Audio Greeting */
export interface Audio {
    /** Id of document */
    readonly id?: string;
    audioMp3?: StoredFile;
    audioWav?: StoredFile;
    /** Name of audio */
    friendlyName?: string;
    /** Duration of audio in seconds */
    readonly durationInSeconds?: number;
    /** Description of audio */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for Audios */
export interface AudioFilterRequest {
    /** AudioMp3.InstanceId equals */
    audioMp3_instanceId_eq?: string | null;
    /** AudioMp3.InstanceId contains */
    audioMp3_instanceId_con?: string | null;
    /** AudioMp3.InstanceId regex */
    audioMp3_instanceId_reg?: string | null;
    /** AudioMp3.FileSizeInBytes equals */
    audioMp3_fileSizeInBytes_eq?: number | null;
    /** AudioMp3.FileSizeInBytes less than or equal to */
    audioMp3_fileSizeInBytes_lte?: number | null;
    /** AudioMp3.FileSizeInBytes greater than or equal to */
    audioMp3_fileSizeInBytes_gte?: number | null;
    /** AudioMp3.Md5Hash equals */
    audioMp3_md5Hash_eq?: string | null;
    /** AudioMp3.Md5Hash contains */
    audioMp3_md5Hash_con?: string | null;
    /** AudioMp3.Md5Hash regex */
    audioMp3_md5Hash_reg?: string | null;
    /** AudioMp3.Url equals */
    audioMp3_url_eq?: string | null;
    /** AudioMp3.Url contains */
    audioMp3_url_con?: string | null;
    /** AudioMp3.Url regex */
    audioMp3_url_reg?: string | null;
    /** AudioMp3.Id equals */
    audioMp3_id_eq?: string | null;
    /** AudioMp3.Id contains */
    audioMp3_id_con?: string | null;
    /** AudioMp3.Id regex */
    audioMp3_id_reg?: string | null;
    /** AudioWav.InstanceId equals */
    audioWav_instanceId_eq?: string | null;
    /** AudioWav.InstanceId contains */
    audioWav_instanceId_con?: string | null;
    /** AudioWav.InstanceId regex */
    audioWav_instanceId_reg?: string | null;
    /** AudioWav.FileSizeInBytes equals */
    audioWav_fileSizeInBytes_eq?: number | null;
    /** AudioWav.FileSizeInBytes less than or equal to */
    audioWav_fileSizeInBytes_lte?: number | null;
    /** AudioWav.FileSizeInBytes greater than or equal to */
    audioWav_fileSizeInBytes_gte?: number | null;
    /** AudioWav.Md5Hash equals */
    audioWav_md5Hash_eq?: string | null;
    /** AudioWav.Md5Hash contains */
    audioWav_md5Hash_con?: string | null;
    /** AudioWav.Md5Hash regex */
    audioWav_md5Hash_reg?: string | null;
    /** AudioWav.Url equals */
    audioWav_url_eq?: string | null;
    /** AudioWav.Url contains */
    audioWav_url_con?: string | null;
    /** AudioWav.Url regex */
    audioWav_url_reg?: string | null;
    /** AudioWav.Id equals */
    audioWav_id_eq?: string | null;
    /** AudioWav.Id contains */
    audioWav_id_con?: string | null;
    /** AudioWav.Id regex */
    audioWav_id_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Mp3 or Wav audio file. Previously called Audio Greeting */
export interface AudioUpdateRequest {
    /** Name of audio */
    friendlyName?: string | null;
    /** Description of audio */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Id is the mac address of a phone. It should point to an ip phone */
export interface AutoProvisionReference {
    /** Id of document */
    readonly id?: string;
    /** Ip address where it was autoprovisioned */
    readonly ip?: string;
    /** Ip address where it was autoprovisioned */
    readonly userAgent?: string;
    /** Phone was autoprovisioned by whom? This is the session that gave permission to the phone to autoprovision.
The phone makes autoprovision with a pin. With the pin we retrive the session of the user that had that pin. */
    readonly idUserThatAllowedAutoprovision?: string | null;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Phone numbers that will be blocked */
export interface BlackListPhoneNumber {
    /** Id of document */
    readonly id?: string;
    /** Optional audio to play if call is blocked */
    idAudioToPlayIfCallIsBlocked?: string | null;
    /** The phone number that will be blocked */
    number?: string;
    /** Friendly name of this rule */
    friendlyName?: string;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for BlackListPhoneNumbers */
export interface BlackListPhoneNumberFilterRequest {
    /** IdAudioToPlayIfCallIsBlocked equals */
    idAudioToPlayIfCallIsBlocked_eq?: string | null;
    /** IdAudioToPlayIfCallIsBlocked contains */
    idAudioToPlayIfCallIsBlocked_con?: string | null;
    /** IdAudioToPlayIfCallIsBlocked regex */
    idAudioToPlayIfCallIsBlocked_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Phone numbers that will be blocked */
export interface BlackListPhoneNumberUpdateRequest {
    /** Optional audio to play if call is blocked */
    idAudioToPlayIfCallIsBlocked?: string | null;
    /** The phone number that will be blocked */
    number?: string | null;
    /** Friendly name of this rule */
    friendlyName?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Outgoing is the channel that makes the call Incoming is the channel receiveing the call */
export enum BlfStatusType {
    None = "None",
    Outgoing_Ringing = "Outgoing_Ringing",
    Outgoing_InProgress = "Outgoing_InProgress",
    Outgiong_OnHold = "Outgiong_OnHold",
    Incoming_Ringing = "Incoming_Ringing",
    Incoming_InProgress = "Incoming_InProgress",
    Incoming_OnHold = "Incoming_OnHold",
}

/** Ublux phone call */
export interface Call {
    /** Id of document */
    readonly id?: string;
    /** Id of voicemail in case there is one */
    readonly idVoicemail?: string | null;
    /** This call was originated with the purpose of tranfering another call with this id    
When this variable is set the call is marked as completed */
    readonly idCallThatTerminatedThisCallDoToAttendantTransfer?: string | null;
    /** If outgoing:
    Reference of contact that we are calling
If incoming:
    Reference of of Contact that called us */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Refernce to AI call transcription */
    readonly idAiCallTranscription?: string | null;
    channelVariables?: ChannelVariables;
    /** Child calls */
    readonly childCalls?: ChildCall[];
    /** ANSWER: Call is answered. A successful dial. The caller reached the callee.
BUSY: Busy signal. The dial command reached its number but the number is busy.
NOANSWER: No answer. The dial command reached its number, the number ring for too long, then the dial timed out.
CANCEL: Call is canceled. The dial command reached its number but the caller hung up before the callee picked up.
CONGESTION: Congestion. This status is usually a sign that the dialed number is not recognized.
CHANUNAVAIL: Channel unavailable. On SIP, peer may not be registered. */
    readonly dialStatus?: string;
    /** Number of seconds it took to answer */
    readonly secondsItTookToAnswer?: number | null;
    /** Dates when call is placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    callType?: CallType;
    recording?: Recording;
    /** Was video disabled on call? */
    readonly disabledVideo?: boolean;
    /** List because user can send digits multiple times */
    readonly digitsSent?: string[];
    /** Is call international. This does not include child calls. */
    readonly isInternational?: boolean;
    /** True if it contains any child call or master call international */
    readonly containsInternationalCall?: boolean;
    callResult?: CallResult;
    aiCallAnalysisOutput?: AiCallAnalysisOutput;
    /** AI input */
    readonly idAiCallAnalysisInput?: string | null;
    /** Lines that participated in this call */
    readonly idsParticipantLines?: string[];
    /** If not null it means the call is ended */
    readonly durationInSeconds?: number | null;
    errors?: CallErrors;
    recordingStatus?: ProcessStatus;
    aiTranscriptionStatus?: ProcessStatus;
    aiAnalysisStatus?: ProcessStatus;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Call errors */
export interface CallErrors {
    /** Errors with call in general. For example: Call made to none existing extension. */
    readonly errorsCall?: string[];
    /** Errors with call recoding. For example: It was not possible to store recording. */
    readonly errorsRecording?: string[];
    /** Errors with dealing converting call audio to text. For example: Transcription service is not available; therefore, it was not possible to transcribe call */
    readonly errorsAiTranscription?: string[];
    /** Errors with AI engine. For example: Call is too short and does not contain any relevant information to be AI analyzed. */
    readonly errorsAiAnalysis?: string[];
}

/** Enables searching for Calls */
export interface CallFilterRequest {
    /** IdVoicemail equals */
    idVoicemail_eq?: string | null;
    /** IdVoicemail contains */
    idVoicemail_con?: string | null;
    /** IdVoicemail regex */
    idVoicemail_reg?: string | null;
    /** IdCallThatTerminatedThisCallDoToAttendantTransfer equals */
    idCallThatTerminatedThisCallDoToAttendantTransfer_eq?: string | null;
    /** IdCallThatTerminatedThisCallDoToAttendantTransfer contains */
    idCallThatTerminatedThisCallDoToAttendantTransfer_con?: string | null;
    /** IdCallThatTerminatedThisCallDoToAttendantTransfer regex */
    idCallThatTerminatedThisCallDoToAttendantTransfer_reg?: string | null;
    /** IdContact equals */
    idContact_eq?: string | null;
    /** IdContact contains */
    idContact_con?: string | null;
    /** IdContact regex */
    idContact_reg?: string | null;
    /** ContactFullName equals */
    contactFullName_eq?: string | null;
    /** ContactFullName contains */
    contactFullName_con?: string | null;
    /** ContactFullName regex */
    contactFullName_reg?: string | null;
    /** IdAiCallTranscription equals */
    idAiCallTranscription_eq?: string | null;
    /** IdAiCallTranscription contains */
    idAiCallTranscription_con?: string | null;
    /** IdAiCallTranscription regex */
    idAiCallTranscription_reg?: string | null;
    /** ChannelVariables.Language equals */
    channelVariables_language_eq?: string | null;
    /** ChannelVariables.Language contains */
    channelVariables_language_con?: string | null;
    /** ChannelVariables.Language regex */
    channelVariables_language_reg?: string | null;
    /** ChannelVariables.IdMusicOnHoldGroup equals */
    channelVariables_idMusicOnHoldGroup_eq?: string | null;
    /** ChannelVariables.IdMusicOnHoldGroup contains */
    channelVariables_idMusicOnHoldGroup_con?: string | null;
    /** ChannelVariables.IdMusicOnHoldGroup regex */
    channelVariables_idMusicOnHoldGroup_reg?: string | null;
    /** ChannelVariables.CallerIdName equals */
    channelVariables_callerIdName_eq?: string | null;
    /** ChannelVariables.CallerIdName contains */
    channelVariables_callerIdName_con?: string | null;
    /** ChannelVariables.CallerIdName regex */
    channelVariables_callerIdName_reg?: string | null;
    /** ChannelVariables.CallerIdNumber equals */
    channelVariables_callerIdNumber_eq?: string | null;
    /** ChannelVariables.CallerIdNumber contains */
    channelVariables_callerIdNumber_con?: string | null;
    /** ChannelVariables.CallerIdNumber regex */
    channelVariables_callerIdNumber_reg?: string | null;
    /** ChildCalls.ChildCallType equals */
    childCalls_childCallType_eq?: string | null;
    /** ChildCalls.ChildCallType contains */
    childCalls_childCallType_con?: string | null;
    /** ChildCalls.ChildCallType regex */
    childCalls_childCallType_reg?: string | null;
    /** ChildCalls.DialStatus equals */
    childCalls_dialStatus_eq?: string | null;
    /** ChildCalls.DialStatus contains */
    childCalls_dialStatus_con?: string | null;
    /** ChildCalls.DialStatus regex */
    childCalls_dialStatus_reg?: string | null;
    /** ChildCalls.DateCreated equals */
    childCalls_dateCreated_eq?: Date | null;
    /** ChildCalls.DateCreated less than or equal to */
    childCalls_dateCreated_lte?: Date | null;
    /** ChildCalls.DateCreated greater than or equal to */
    childCalls_dateCreated_gte?: Date | null;
    /** ChildCalls.From equals */
    childCalls_from_eq?: string | null;
    /** ChildCalls.From contains */
    childCalls_from_con?: string | null;
    /** ChildCalls.From regex */
    childCalls_from_reg?: string | null;
    /** ChildCalls.FromCountry equals */
    childCalls_fromCountry_eq?: string | null;
    /** ChildCalls.FromCountry contains */
    childCalls_fromCountry_con?: string | null;
    /** ChildCalls.FromCountry regex */
    childCalls_fromCountry_reg?: string | null;
    /** ChildCalls.To equals */
    childCalls_to_eq?: string | null;
    /** ChildCalls.To contains */
    childCalls_to_con?: string | null;
    /** ChildCalls.To regex */
    childCalls_to_reg?: string | null;
    /** ChildCalls.ToCountry equals */
    childCalls_toCountry_eq?: string | null;
    /** ChildCalls.ToCountry contains */
    childCalls_toCountry_con?: string | null;
    /** ChildCalls.ToCountry regex */
    childCalls_toCountry_reg?: string | null;
    /** ChildCalls.IsInternational equals */
    childCalls_isInternational_eq?: boolean | null;
    /** DialStatus equals */
    dialStatus_eq?: string | null;
    /** DialStatus contains */
    dialStatus_con?: string | null;
    /** DialStatus regex */
    dialStatus_reg?: string | null;
    /** From equals */
    from_eq?: string | null;
    /** From contains */
    from_con?: string | null;
    /** From regex */
    from_reg?: string | null;
    /** FromCountry equals */
    fromCountry_eq?: string | null;
    /** FromCountry contains */
    fromCountry_con?: string | null;
    /** FromCountry regex */
    fromCountry_reg?: string | null;
    /** To equals */
    to_eq?: string | null;
    /** To contains */
    to_con?: string | null;
    /** To regex */
    to_reg?: string | null;
    /** ToCountry equals */
    toCountry_eq?: string | null;
    /** ToCountry contains */
    toCountry_con?: string | null;
    /** ToCountry regex */
    toCountry_reg?: string | null;
    /** CallType equals */
    callType_eq?: string | null;
    /** CallType contains */
    callType_con?: string | null;
    /** CallType regex */
    callType_reg?: string | null;
    /** Recording.ErrorMessage equals */
    recording_errorMessage_eq?: string | null;
    /** Recording.ErrorMessage contains */
    recording_errorMessage_con?: string | null;
    /** Recording.ErrorMessage regex */
    recording_errorMessage_reg?: string | null;
    /** Recording.RecordingClientMp3.InstanceId equals */
    recording_recordingClientMp3_instanceId_eq?: string | null;
    /** Recording.RecordingClientMp3.InstanceId contains */
    recording_recordingClientMp3_instanceId_con?: string | null;
    /** Recording.RecordingClientMp3.InstanceId regex */
    recording_recordingClientMp3_instanceId_reg?: string | null;
    /** Recording.RecordingClientMp3.FileSizeInBytes equals */
    recording_recordingClientMp3_fileSizeInBytes_eq?: number | null;
    /** Recording.RecordingClientMp3.FileSizeInBytes less than or equal to */
    recording_recordingClientMp3_fileSizeInBytes_lte?: number | null;
    /** Recording.RecordingClientMp3.FileSizeInBytes greater than or equal to */
    recording_recordingClientMp3_fileSizeInBytes_gte?: number | null;
    /** Recording.RecordingClientMp3.Md5Hash equals */
    recording_recordingClientMp3_md5Hash_eq?: string | null;
    /** Recording.RecordingClientMp3.Md5Hash contains */
    recording_recordingClientMp3_md5Hash_con?: string | null;
    /** Recording.RecordingClientMp3.Md5Hash regex */
    recording_recordingClientMp3_md5Hash_reg?: string | null;
    /** Recording.RecordingClientMp3.Url equals */
    recording_recordingClientMp3_url_eq?: string | null;
    /** Recording.RecordingClientMp3.Url contains */
    recording_recordingClientMp3_url_con?: string | null;
    /** Recording.RecordingClientMp3.Url regex */
    recording_recordingClientMp3_url_reg?: string | null;
    /** Recording.RecordingClientMp3.Id equals */
    recording_recordingClientMp3_id_eq?: string | null;
    /** Recording.RecordingClientMp3.Id contains */
    recording_recordingClientMp3_id_con?: string | null;
    /** Recording.RecordingClientMp3.Id regex */
    recording_recordingClientMp3_id_reg?: string | null;
    /** Recording.RecordingAgentMp3.InstanceId equals */
    recording_recordingAgentMp3_instanceId_eq?: string | null;
    /** Recording.RecordingAgentMp3.InstanceId contains */
    recording_recordingAgentMp3_instanceId_con?: string | null;
    /** Recording.RecordingAgentMp3.InstanceId regex */
    recording_recordingAgentMp3_instanceId_reg?: string | null;
    /** Recording.RecordingAgentMp3.FileSizeInBytes equals */
    recording_recordingAgentMp3_fileSizeInBytes_eq?: number | null;
    /** Recording.RecordingAgentMp3.FileSizeInBytes less than or equal to */
    recording_recordingAgentMp3_fileSizeInBytes_lte?: number | null;
    /** Recording.RecordingAgentMp3.FileSizeInBytes greater than or equal to */
    recording_recordingAgentMp3_fileSizeInBytes_gte?: number | null;
    /** Recording.RecordingAgentMp3.Md5Hash equals */
    recording_recordingAgentMp3_md5Hash_eq?: string | null;
    /** Recording.RecordingAgentMp3.Md5Hash contains */
    recording_recordingAgentMp3_md5Hash_con?: string | null;
    /** Recording.RecordingAgentMp3.Md5Hash regex */
    recording_recordingAgentMp3_md5Hash_reg?: string | null;
    /** Recording.RecordingAgentMp3.Url equals */
    recording_recordingAgentMp3_url_eq?: string | null;
    /** Recording.RecordingAgentMp3.Url contains */
    recording_recordingAgentMp3_url_con?: string | null;
    /** Recording.RecordingAgentMp3.Url regex */
    recording_recordingAgentMp3_url_reg?: string | null;
    /** Recording.RecordingAgentMp3.Id equals */
    recording_recordingAgentMp3_id_eq?: string | null;
    /** Recording.RecordingAgentMp3.Id contains */
    recording_recordingAgentMp3_id_con?: string | null;
    /** Recording.RecordingAgentMp3.Id regex */
    recording_recordingAgentMp3_id_reg?: string | null;
    /** Recording.RecordingMp3.InstanceId equals */
    recording_recordingMp3_instanceId_eq?: string | null;
    /** Recording.RecordingMp3.InstanceId contains */
    recording_recordingMp3_instanceId_con?: string | null;
    /** Recording.RecordingMp3.InstanceId regex */
    recording_recordingMp3_instanceId_reg?: string | null;
    /** Recording.RecordingMp3.FileSizeInBytes equals */
    recording_recordingMp3_fileSizeInBytes_eq?: number | null;
    /** Recording.RecordingMp3.FileSizeInBytes less than or equal to */
    recording_recordingMp3_fileSizeInBytes_lte?: number | null;
    /** Recording.RecordingMp3.FileSizeInBytes greater than or equal to */
    recording_recordingMp3_fileSizeInBytes_gte?: number | null;
    /** Recording.RecordingMp3.Md5Hash equals */
    recording_recordingMp3_md5Hash_eq?: string | null;
    /** Recording.RecordingMp3.Md5Hash contains */
    recording_recordingMp3_md5Hash_con?: string | null;
    /** Recording.RecordingMp3.Md5Hash regex */
    recording_recordingMp3_md5Hash_reg?: string | null;
    /** Recording.RecordingMp3.Url equals */
    recording_recordingMp3_url_eq?: string | null;
    /** Recording.RecordingMp3.Url contains */
    recording_recordingMp3_url_con?: string | null;
    /** Recording.RecordingMp3.Url regex */
    recording_recordingMp3_url_reg?: string | null;
    /** Recording.RecordingMp3.Id equals */
    recording_recordingMp3_id_eq?: string | null;
    /** Recording.RecordingMp3.Id contains */
    recording_recordingMp3_id_con?: string | null;
    /** Recording.RecordingMp3.Id regex */
    recording_recordingMp3_id_reg?: string | null;
    /** Recording.Id equals */
    recording_id_eq?: string | null;
    /** Recording.Id contains */
    recording_id_con?: string | null;
    /** Recording.Id regex */
    recording_id_reg?: string | null;
    /** DisabledVideo equals */
    disabledVideo_eq?: boolean | null;
    /** DigitsSent equals */
    digitsSent_eq?: string | null;
    /** DigitsSent contains */
    digitsSent_con?: string | null;
    /** DigitsSent regex */
    digitsSent_reg?: string | null;
    /** IsInternational equals */
    isInternational_eq?: boolean | null;
    /** ContainsInternationalCall equals */
    containsInternationalCall_eq?: boolean | null;
    /** CallResult equals */
    callResult_eq?: string | null;
    /** CallResult contains */
    callResult_con?: string | null;
    /** CallResult regex */
    callResult_reg?: string | null;
    /** AiCallAnalysisOutput.IdAiCallAnalysisInput equals */
    aiCallAnalysisOutput_idAiCallAnalysisInput_eq?: string | null;
    /** AiCallAnalysisOutput.IdAiCallAnalysisInput contains */
    aiCallAnalysisOutput_idAiCallAnalysisInput_con?: string | null;
    /** AiCallAnalysisOutput.IdAiCallAnalysisInput regex */
    aiCallAnalysisOutput_idAiCallAnalysisInput_reg?: string | null;
    /** AiCallAnalysisOutput.DetectedLanguage equals */
    aiCallAnalysisOutput_detectedLanguage_eq?: string | null;
    /** AiCallAnalysisOutput.DetectedLanguage contains */
    aiCallAnalysisOutput_detectedLanguage_con?: string | null;
    /** AiCallAnalysisOutput.DetectedLanguage regex */
    aiCallAnalysisOutput_detectedLanguage_reg?: string | null;
    /** AiCallAnalysisOutput.Output.Name equals */
    aiCallAnalysisOutput_output_name_eq?: string | null;
    /** AiCallAnalysisOutput.Output.Name contains */
    aiCallAnalysisOutput_output_name_con?: string | null;
    /** AiCallAnalysisOutput.Output.Name regex */
    aiCallAnalysisOutput_output_name_reg?: string | null;
    /** AiCallAnalysisOutput.Output.AiVariableType equals */
    aiCallAnalysisOutput_output_aiVariableType_eq?: string | null;
    /** AiCallAnalysisOutput.Output.AiVariableType contains */
    aiCallAnalysisOutput_output_aiVariableType_con?: string | null;
    /** AiCallAnalysisOutput.Output.AiVariableType regex */
    aiCallAnalysisOutput_output_aiVariableType_reg?: string | null;
    /** AiCallAnalysisOutput.Output.Value equals */
    aiCallAnalysisOutput_output_value_eq?: string | null;
    /** AiCallAnalysisOutput.Output.Value contains */
    aiCallAnalysisOutput_output_value_con?: string | null;
    /** AiCallAnalysisOutput.Output.Value regex */
    aiCallAnalysisOutput_output_value_reg?: string | null;
    /** AiCallAnalysisOutput.TokensTotal equals */
    aiCallAnalysisOutput_tokensTotal_eq?: number | null;
    /** AiCallAnalysisOutput.TokensTotal less than or equal to */
    aiCallAnalysisOutput_tokensTotal_lte?: number | null;
    /** AiCallAnalysisOutput.TokensTotal greater than or equal to */
    aiCallAnalysisOutput_tokensTotal_gte?: number | null;
    /** AiCallAnalysisOutput.TokensCompletion equals */
    aiCallAnalysisOutput_tokensCompletion_eq?: number | null;
    /** AiCallAnalysisOutput.TokensCompletion less than or equal to */
    aiCallAnalysisOutput_tokensCompletion_lte?: number | null;
    /** AiCallAnalysisOutput.TokensCompletion greater than or equal to */
    aiCallAnalysisOutput_tokensCompletion_gte?: number | null;
    /** AiCallAnalysisOutput.TokensPrompt equals */
    aiCallAnalysisOutput_tokensPrompt_eq?: number | null;
    /** AiCallAnalysisOutput.TokensPrompt less than or equal to */
    aiCallAnalysisOutput_tokensPrompt_lte?: number | null;
    /** AiCallAnalysisOutput.TokensPrompt greater than or equal to */
    aiCallAnalysisOutput_tokensPrompt_gte?: number | null;
    /** IdAiCallAnalysisInput equals */
    idAiCallAnalysisInput_eq?: string | null;
    /** IdAiCallAnalysisInput contains */
    idAiCallAnalysisInput_con?: string | null;
    /** IdAiCallAnalysisInput regex */
    idAiCallAnalysisInput_reg?: string | null;
    /** IdsParticipantLines equals */
    idsParticipantLines_eq?: string | null;
    /** IdsParticipantLines contains */
    idsParticipantLines_con?: string | null;
    /** IdsParticipantLines regex */
    idsParticipantLines_reg?: string | null;
    /** Errors.ErrorsCall equals */
    errors_errorsCall_eq?: string | null;
    /** Errors.ErrorsCall contains */
    errors_errorsCall_con?: string | null;
    /** Errors.ErrorsCall regex */
    errors_errorsCall_reg?: string | null;
    /** Errors.ErrorsRecording equals */
    errors_errorsRecording_eq?: string | null;
    /** Errors.ErrorsRecording contains */
    errors_errorsRecording_con?: string | null;
    /** Errors.ErrorsRecording regex */
    errors_errorsRecording_reg?: string | null;
    /** Errors.ErrorsAiTranscription equals */
    errors_errorsAiTranscription_eq?: string | null;
    /** Errors.ErrorsAiTranscription contains */
    errors_errorsAiTranscription_con?: string | null;
    /** Errors.ErrorsAiTranscription regex */
    errors_errorsAiTranscription_reg?: string | null;
    /** Errors.ErrorsAiAnalysis equals */
    errors_errorsAiAnalysis_eq?: string | null;
    /** Errors.ErrorsAiAnalysis contains */
    errors_errorsAiAnalysis_con?: string | null;
    /** Errors.ErrorsAiAnalysis regex */
    errors_errorsAiAnalysis_reg?: string | null;
    /** RecordingStatus equals */
    recordingStatus_eq?: string | null;
    /** RecordingStatus contains */
    recordingStatus_con?: string | null;
    /** RecordingStatus regex */
    recordingStatus_reg?: string | null;
    /** AiTranscriptionStatus equals */
    aiTranscriptionStatus_eq?: string | null;
    /** AiTranscriptionStatus contains */
    aiTranscriptionStatus_con?: string | null;
    /** AiTranscriptionStatus regex */
    aiTranscriptionStatus_reg?: string | null;
    /** AiAnalysisStatus equals */
    aiAnalysisStatus_eq?: string | null;
    /** AiAnalysisStatus contains */
    aiAnalysisStatus_con?: string | null;
    /** AiAnalysisStatus regex */
    aiAnalysisStatus_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Virtual receptionist */
export interface CallFlowLogic {
    /** Id of document */
    readonly id?: string;
    /** Name of virtual receptionist */
    friendlyName?: string;
    /** Description of virtual receptionist */
    description?: string | null;
    tree?: FlowNode;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for CallFlowLogics */
export interface CallFlowLogicFilterRequest {
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Tree.FlowNodeType equals */
    tree_flowNodeType_eq?: string | null;
    /** Tree.FlowNodeType contains */
    tree_flowNodeType_con?: string | null;
    /** Tree.FlowNodeType regex */
    tree_flowNodeType_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Virtual receptionist */
export interface CallFlowLogicUpdateRequest {
    /** Name of virtual receptionist */
    friendlyName?: string | null;
    /** Description of virtual receptionist */
    description?: string | null;
    tree?: FlowNode;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Incoming phone call that executed an IVR */
export interface CallIncomingToCallFlowLogic {
    /** Id of document */
    readonly id?: string;
    /** Id of Call Flow (IVR) to execute */
    readonly idCallFlowLogic?: string;
    callType?: CallType;
    /** VOIP phone number that received the phone call */
    readonly idVoipNumberPhone?: string;
    /** Phone number that received phone call in international format */
    readonly fromInternationalFormat?: string;
    /** Providers send us the information if call is being forwarded. It may be helpful to store this. */
    readonly forwardedBy?: string | null;
    /** Id of voicemail in case there is one */
    readonly idVoicemail?: string | null;
    /** This call was originated with the purpose of tranfering another call with this id    
When this variable is set the call is marked as completed */
    readonly idCallThatTerminatedThisCallDoToAttendantTransfer?: string | null;
    /** If outgoing:
    Reference of contact that we are calling
If incoming:
    Reference of of Contact that called us */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Refernce to AI call transcription */
    readonly idAiCallTranscription?: string | null;
    channelVariables?: ChannelVariables;
    /** Child calls */
    readonly childCalls?: ChildCall[];
    /** ANSWER: Call is answered. A successful dial. The caller reached the callee.
BUSY: Busy signal. The dial command reached its number but the number is busy.
NOANSWER: No answer. The dial command reached its number, the number ring for too long, then the dial timed out.
CANCEL: Call is canceled. The dial command reached its number but the caller hung up before the callee picked up.
CONGESTION: Congestion. This status is usually a sign that the dialed number is not recognized.
CHANUNAVAIL: Channel unavailable. On SIP, peer may not be registered. */
    readonly dialStatus?: string;
    /** Number of seconds it took to answer */
    readonly secondsItTookToAnswer?: number | null;
    /** Dates when call is placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    recording?: Recording;
    /** Was video disabled on call? */
    readonly disabledVideo?: boolean;
    /** List because user can send digits multiple times */
    readonly digitsSent?: string[];
    /** Is call international. This does not include child calls. */
    readonly isInternational?: boolean;
    /** True if it contains any child call or master call international */
    readonly containsInternationalCall?: boolean;
    callResult?: CallResult;
    aiCallAnalysisOutput?: AiCallAnalysisOutput;
    /** AI input */
    readonly idAiCallAnalysisInput?: string | null;
    /** Lines that participated in this call */
    readonly idsParticipantLines?: string[];
    /** If not null it means the call is ended */
    readonly durationInSeconds?: number | null;
    errors?: CallErrors;
    recordingStatus?: ProcessStatus;
    aiTranscriptionStatus?: ProcessStatus;
    aiAnalysisStatus?: ProcessStatus;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Incoming phone call from PSTN to an extension */
export interface CallIncomingToExtension {
    /** Id of document */
    readonly id?: string;
    /** Extension being called */
    readonly idExtension?: string | null;
    /** Line that answered */
    readonly idLineThatAnswered?: string | null;
    /** Lines that ring */
    readonly idsLinesThatRing?: string[];
    /** Lines that did not ring */
    readonly idsLinesThatDidNotRing?: string[];
    callType?: CallType;
    /** VOIP phone number that received the phone call */
    readonly idVoipNumberPhone?: string;
    /** Phone number that received phone call in international format */
    readonly fromInternationalFormat?: string;
    /** Providers send us the information if call is being forwarded. It may be helpful to store this. */
    readonly forwardedBy?: string | null;
    /** Id of voicemail in case there is one */
    readonly idVoicemail?: string | null;
    /** This call was originated with the purpose of tranfering another call with this id    
When this variable is set the call is marked as completed */
    readonly idCallThatTerminatedThisCallDoToAttendantTransfer?: string | null;
    /** If outgoing:
    Reference of contact that we are calling
If incoming:
    Reference of of Contact that called us */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Refernce to AI call transcription */
    readonly idAiCallTranscription?: string | null;
    channelVariables?: ChannelVariables;
    /** Child calls */
    readonly childCalls?: ChildCall[];
    /** ANSWER: Call is answered. A successful dial. The caller reached the callee.
BUSY: Busy signal. The dial command reached its number but the number is busy.
NOANSWER: No answer. The dial command reached its number, the number ring for too long, then the dial timed out.
CANCEL: Call is canceled. The dial command reached its number but the caller hung up before the callee picked up.
CONGESTION: Congestion. This status is usually a sign that the dialed number is not recognized.
CHANUNAVAIL: Channel unavailable. On SIP, peer may not be registered. */
    readonly dialStatus?: string;
    /** Number of seconds it took to answer */
    readonly secondsItTookToAnswer?: number | null;
    /** Dates when call is placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    recording?: Recording;
    /** Was video disabled on call? */
    readonly disabledVideo?: boolean;
    /** List because user can send digits multiple times */
    readonly digitsSent?: string[];
    /** Is call international. This does not include child calls. */
    readonly isInternational?: boolean;
    /** True if it contains any child call or master call international */
    readonly containsInternationalCall?: boolean;
    callResult?: CallResult;
    aiCallAnalysisOutput?: AiCallAnalysisOutput;
    /** AI input */
    readonly idAiCallAnalysisInput?: string | null;
    /** Lines that participated in this call */
    readonly idsParticipantLines?: string[];
    /** If not null it means the call is ended */
    readonly durationInSeconds?: number | null;
    errors?: CallErrors;
    recordingStatus?: ProcessStatus;
    aiTranscriptionStatus?: ProcessStatus;
    aiAnalysisStatus?: ProcessStatus;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Call made to an extension */
export interface CallOutgoingToExtension {
    /** Id of document */
    readonly id?: string;
    /** Extension being called */
    readonly idExtension?: string | null;
    /** Line that answered */
    readonly idLineThatAnswered?: string | null;
    /** Lines that ring */
    readonly idsLinesThatRing?: string[];
    /** Lines that did not ring */
    readonly idsLinesThatDidNotRing?: string[];
    toCountry?: CountryIsoCode;
    fromCountry?: CountryIsoCode;
    callType?: CallType;
    /** Line that started phone call */
    readonly idLineThatInitiatedCall?: string;
    /** Id of voicemail in case there is one */
    readonly idVoicemail?: string | null;
    /** This call was originated with the purpose of tranfering another call with this id    
When this variable is set the call is marked as completed */
    readonly idCallThatTerminatedThisCallDoToAttendantTransfer?: string | null;
    /** If outgoing:
    Reference of contact that we are calling
If incoming:
    Reference of of Contact that called us */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Refernce to AI call transcription */
    readonly idAiCallTranscription?: string | null;
    channelVariables?: ChannelVariables;
    /** Child calls */
    readonly childCalls?: ChildCall[];
    /** ANSWER: Call is answered. A successful dial. The caller reached the callee.
BUSY: Busy signal. The dial command reached its number but the number is busy.
NOANSWER: No answer. The dial command reached its number, the number ring for too long, then the dial timed out.
CANCEL: Call is canceled. The dial command reached its number but the caller hung up before the callee picked up.
CONGESTION: Congestion. This status is usually a sign that the dialed number is not recognized.
CHANUNAVAIL: Channel unavailable. On SIP, peer may not be registered. */
    readonly dialStatus?: string;
    /** Number of seconds it took to answer */
    readonly secondsItTookToAnswer?: number | null;
    /** Dates when call is placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Caller id */
    readonly from?: string;
    /** Phone number called */
    readonly to?: string;
    recording?: Recording;
    /** Was video disabled on call? */
    readonly disabledVideo?: boolean;
    /** List because user can send digits multiple times */
    readonly digitsSent?: string[];
    /** Is call international. This does not include child calls. */
    readonly isInternational?: boolean;
    /** True if it contains any child call or master call international */
    readonly containsInternationalCall?: boolean;
    callResult?: CallResult;
    aiCallAnalysisOutput?: AiCallAnalysisOutput;
    /** AI input */
    readonly idAiCallAnalysisInput?: string | null;
    /** Lines that participated in this call */
    readonly idsParticipantLines?: string[];
    /** If not null it means the call is ended */
    readonly durationInSeconds?: number | null;
    errors?: CallErrors;
    recordingStatus?: ProcessStatus;
    aiTranscriptionStatus?: ProcessStatus;
    aiAnalysisStatus?: ProcessStatus;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Call made to cell phone or land line */
export interface CallOutgoingToPSTN {
    /** Id of document */
    readonly id?: string;
    callType?: CallType;
    /** Phone number dialed in international format. Property To should contain number that was actually dialed */
    readonly toInternationalFormat?: string;
    /** Line that started phone call */
    readonly idLineThatInitiatedCall?: string;
    /** Id of voicemail in case there is one */
    readonly idVoicemail?: string | null;
    /** This call was originated with the purpose of tranfering another call with this id    
When this variable is set the call is marked as completed */
    readonly idCallThatTerminatedThisCallDoToAttendantTransfer?: string | null;
    /** If outgoing:
    Reference of contact that we are calling
If incoming:
    Reference of of Contact that called us */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Refernce to AI call transcription */
    readonly idAiCallTranscription?: string | null;
    channelVariables?: ChannelVariables;
    /** Child calls */
    readonly childCalls?: ChildCall[];
    /** ANSWER: Call is answered. A successful dial. The caller reached the callee.
BUSY: Busy signal. The dial command reached its number but the number is busy.
NOANSWER: No answer. The dial command reached its number, the number ring for too long, then the dial timed out.
CANCEL: Call is canceled. The dial command reached its number but the caller hung up before the callee picked up.
CONGESTION: Congestion. This status is usually a sign that the dialed number is not recognized.
CHANUNAVAIL: Channel unavailable. On SIP, peer may not be registered. */
    readonly dialStatus?: string;
    /** Number of seconds it took to answer */
    readonly secondsItTookToAnswer?: number | null;
    /** Dates when call is placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    recording?: Recording;
    /** Was video disabled on call? */
    readonly disabledVideo?: boolean;
    /** List because user can send digits multiple times */
    readonly digitsSent?: string[];
    /** Is call international. This does not include child calls. */
    readonly isInternational?: boolean;
    /** True if it contains any child call or master call international */
    readonly containsInternationalCall?: boolean;
    callResult?: CallResult;
    aiCallAnalysisOutput?: AiCallAnalysisOutput;
    /** AI input */
    readonly idAiCallAnalysisInput?: string | null;
    /** Lines that participated in this call */
    readonly idsParticipantLines?: string[];
    /** If not null it means the call is ended */
    readonly durationInSeconds?: number | null;
    errors?: CallErrors;
    recordingStatus?: ProcessStatus;
    aiTranscriptionStatus?: ProcessStatus;
    aiAnalysisStatus?: ProcessStatus;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** How a call is categorized as agent when completed */
export enum CallResult {
    None = "None",
    Sale = "Sale",
    Interested = "Interested",
    Reschedule = "Reschedule",
    NotInterested = "NotInterested",
    DoNotCall = "DoNotCall",
}

/** Type of call */
export enum CallType {
    IncomingToCallFlowLogic = "IncomingToCallFlowLogic",
    IncomingToExtension = "IncomingToExtension",
    OutgoingToExtension = "OutgoingToExtension",
    OutgoingToPSTN = "OutgoingToPSTN",
    FeatureVoicemail = "FeatureVoicemail",
    PowerDialer = "PowerDialer",
}

/** Phone numbers that will be blocked */
export interface CallerIdMask {
    /** Id of document */
    readonly id?: string;
    /** The phone that will be used as caller id */
    readonly phoneNumber?: string;
    /** Name of this caller id mask */
    friendlyName?: string;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for CallerIdMasks */
export interface CallerIdMaskFilterRequest {
    /** PhoneNumber equals */
    phoneNumber_eq?: string | null;
    /** PhoneNumber contains */
    phoneNumber_con?: string | null;
    /** PhoneNumber regex */
    phoneNumber_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Phone numbers that will be blocked */
export interface CallerIdMaskUpdateRequest {
    /** Name of this caller id mask */
    friendlyName?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** A phone call with two peers are composed from the union of two channels. Each channel has its variables */
export interface ChannelVariables {
    language?: Language;
    /** Music on hold. This is the music that will be played when the call is placed on hold. */
    idMusicOnHoldGroup?: string | null;
    /** Caller id is composed of a name and phone number. This is the name part of the caller id */
    callerIdName?: string;
    /** Caller id is composed of a name and phone number. This is the phone number part of the caller id */
    callerIdNumber?: string;
}

/** This attributes are needed so that deserialization works. Newtonsoft.Json deserializer must be used. */
export interface ChildCall {
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    childCallType?: ChildCallType;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** Call is attended transferred to extension */
export interface ChildCallAttendantTransferToExtension {
    /** Extension to whom it was transferred */
    idExtension?: string | null;
    childCallType?: ChildCallType;
    /** Id of call that attendant transfered this call */
    idCallAttendantTransfer?: string;
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** Call is attended transferred to land-line or cell-phone */
export interface ChildCallAttendantTransferToPSTN {
    /** Phone number where call was transferred to */
    phoneNumber?: string;
    childCallType?: ChildCallType;
    /** Id of call that attendant transfered this call */
    idCallAttendantTransfer?: string;
    /** Id of contact to whom call is being transfered */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** Call is blind transferred to an extension */
export interface ChildCallBlindTransferToExtension {
    /** Extension where it was blind transferred to */
    idExtension?: string | null;
    childCallType?: ChildCallType;
    /** Id of line that answered */
    idLineThatAnswered?: string | null;
    /** Ids of lines that ring */
    idsLinesThatRing?: string[];
    /** Ids of lines that where supposed to ring and did not ring because phone was offline or disconnected. */
    idsLinesThatDidNotRing?: string[];
    /** Id of call that originated blind transfer */
    idCall?: string;
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** Call is blind transferred to land-line or cell-phone */
export interface ChildCallBlindTransferToPSTN {
    /** Trunk used to make call */
    idTrunkTermination?: string | null;
    childCallType?: ChildCallType;
    /** Id of contact to whom call is being transfered */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Id of call that originated blind transfer */
    idCall?: string;
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** If a call is forwarded to an extension. For example if call is made to an extension dial that is configured to be forwarded to another extension if not answered this child call will be created */
export interface ChildCallForwardToExtension {
    /** Extension being called */
    idExtension?: string | null;
    /** Line that answered */
    idLineThatAnswered?: string | null;
    /** Lines that ring */
    idsLinesThatRing?: string[];
    /** Lines that did not ring */
    idsLinesThatDidNotRing?: string[];
    childCallType?: ChildCallType;
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** Call is transferred to land-line or cell-phone */
export interface ChildCallForwardToPSTN {
    /** Trunk used to make call. Nullable because if trunk does not exist to call some specific country. */
    idTrunkTermination?: string | null;
    childCallType?: ChildCallType;
    /** Id of contact to whom call is being transfered */
    readonly idContact?: string | null;
    /** Contact full name */
    readonly contactFullName?: string | null;
    /** Call duration in seconds */
    readonly durationInSeconds?: number | null;
    /** Status of call */
    dialStatus?: string;
    dateCreated?: Date;
    /** Number of seconds it took to answer */
    secondsItTookToAnswer?: number | null;
    /** Caller id */
    readonly from?: string;
    fromCountry?: CountryIsoCode;
    /** Phone number called */
    readonly to?: string;
    toCountry?: CountryIsoCode;
    /** Is this call international */
    readonly isInternational?: boolean;
}

/** Type of child call */
export enum ChildCallType {
    None = "None",
    ForwardToExtension = "ForwardToExtension",
    ForwardToPSTN = "ForwardToPSTN",
    AttendantTransferToExtension = "AttendantTransferToExtension",
    AttendantTransferToPSTN = "AttendantTransferToPSTN",
    BlindTransferToExtension = "BlindTransferToExtension",
    BlindTransferToPSTN = "BlindTransferToPSTN",
}

/** Base class for cloud services */
export interface CloudService {
    /** Id of document */
    readonly id?: string;
    /** TODO. Place index on this field on DB
Thanks to the user it can login */
    readonly idUser?: string;
    cloudServiceType?: CloudServiceType;
    countryIsoCode?: CountryIsoCode;
    /** If this service is inside a nat what is the local ip address?
This is needed by asterisk sip.conf file */
    readonly localnet?: string | null;
    /** It can have multipe ips but only one should be used.
Hard host name should point to this */
    readonly externalIp?: string | null;
    /** Is this service used as a backup pbx? Failover and NonFailover servers should NEVER overlap. */
    readonly isFailover?: boolean;
    /** Is there a router? For example on Divieto this will be true. On Canal Park this will be false */
    readonly nat?: boolean;
    /** Send this constantly to web service when polling. The pbx sends this */
    readonly isHealthy?: boolean;
    /** Instance Id. Example PBX-US-1 for CSP.PBX-US-1 */
    readonly instanceId?: string;
    /** Is this a test cloud serviec */
    readonly isTest?: boolean;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Used to group a cloud service and user */
export interface CloudServiceAndUser {
    cloudService?: CloudService;
    user?: User;
}

/** Provider that hosts this cloud service */
export enum CloudServiceProviderType {
    None = "None",
    AWS = "AWS",
    Azure = "Azure",
    Ublux = "Ublux",
}

/** Type of cloud service */
export enum CloudServiceType {
    None = "None",
    PBX = "PBX",
    WS = "WS",
    WH = "WH",
    WA = "WA",
}

/** Server where ublux website lives */
export interface CloudServiceWebHost {
    /** Id of document */
    readonly id?: string;
    cloudServiceType?: CloudServiceType;
    /** TODO. Place index on this field on DB
Thanks to the user it can login */
    readonly idUser?: string;
    countryIsoCode?: CountryIsoCode;
    /** If this service is inside a nat what is the local ip address?
This is needed by asterisk sip.conf file */
    readonly localnet?: string | null;
    /** It can have multipe ips but only one should be used.
Hard host name should point to this */
    readonly externalIp?: string | null;
    /** Is this service used as a backup pbx? Failover and NonFailover servers should NEVER overlap. */
    readonly isFailover?: boolean;
    /** Is there a router? For example on Divieto this will be true. On Canal Park this will be false */
    readonly nat?: boolean;
    /** Send this constantly to web service when polling. The pbx sends this */
    readonly isHealthy?: boolean;
    /** Instance Id. Example PBX-US-1 for CSP.PBX-US-1 */
    readonly instanceId?: string;
    /** Is this a test cloud serviec */
    readonly isTest?: boolean;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Database tables */
export enum Collections {
    Accounts = "Accounts",
    AgreementsToTermsAndConditions = "AgreementsToTermsAndConditions",
    AirNetworksProvinces = "AirNetworksProvinces",
    Audios = "Audios",
    AutoProvisionReferences = "AutoProvisionReferences",
    BlackListPhoneNumbers = "BlackListPhoneNumbers",
    Calls = "Calls",
    CallerIdMasks = "CallerIdMasks",
    CallFlowLogics = "CallFlowLogics",
    CloudServices = "CloudServices",
    Contacts = "Contacts",
    CustomerInfos = "CustomerInfos",
    Extensions = "Extensions",
    FaxesIncoming = "FaxesIncoming",
    FaxOutgoingGroups = "FaxOutgoingGroups",
    Voicemails = "Voicemails",
    Users = "Users",
    LineKeyGroups = "LineKeyGroups",
    LogWebServiceRequests = "LogWebServiceRequests",
    MusicOnHoldGroups = "MusicOnHoldGroups",
    Phones = "Phones",
    PhoneConfigurations = "PhoneConfigurations",
    PowerDialerGroups = "PowerDialerGroups",
    SMS = "SMS",
    TrunkOriginations = "TrunkOriginations",
    TrunkTerminations = "TrunkTerminations",
    TrunkTerminationGroups = "TrunkTerminationGroups",
    VoipNumbers = "VoipNumbers",
    VoipProviders = "VoipProviders",
    WebHooks = "WebHooks",
    StoredFileReferences = "StoredFileReferences",
    Tags = "Tags",
    ApiKeys = "ApiKeys",
    AiCallTranscriptions = "AiCallTranscriptions",
    Emails = "Emails",
    AiCallAnalysisInputs = "AiCallAnalysisInputs",
}

/** Contact */
export interface Contact {
    /** Id of document */
    readonly id?: string;
    /** If null it can be seen by entire account. In other words it is a global contact. 
Otherwise it will only be visible to a specific user (user)

Who owns the contact. If null it will belong to entire account */
    readonly idUserOwner?: string | null;
    /** Phone numbers of contact
Key = phone number
Value = type (example = work) */
    contactNumbers?: ContactNumber[];
    /** Email addresses of contact */
    contactEmails?: ContactEmail[];
    /** Mailing Addresses of contact */
    mailingAddresses?: MailingAddress[];
    /** Contact first name */
    firstName?: string | null;
    /** Contact last name */
    lastName?: string | null;
    /** Contact job tittle */
    jobTitle?: string | null;
    company?: string | null;
    /** Contact Notes */
    notes?: string | null;
    /** Customer custom data */
    variables?: Variable[];
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Contact email address */
export interface ContactEmail {
    /** This cannot be the id because if the email address changes we should not change the id.
Thanks to this index we can search fast on database. This index consists of: Account followed by the email address
TODO: make this an index on database. Do not make it unique only and index because we can have two contacts with the same email address */
    readonly searchIndex?: string;
    /** Contact email address */
    email?: string;
    label?: LabelEmailType;
}

/** Enables searching for Contacts */
export interface ContactFilterRequest {
    /** IdUserOwner equals */
    idUserOwner_eq?: string | null;
    /** IdUserOwner contains */
    idUserOwner_con?: string | null;
    /** IdUserOwner regex */
    idUserOwner_reg?: string | null;
    /** ContactNumbers.Number equals */
    contactNumbers_number_eq?: string | null;
    /** ContactNumbers.Number contains */
    contactNumbers_number_con?: string | null;
    /** ContactNumbers.Number regex */
    contactNumbers_number_reg?: string | null;
    /** ContactNumbers.NumberInternationalFormat equals */
    contactNumbers_numberInternationalFormat_eq?: string | null;
    /** ContactNumbers.NumberInternationalFormat contains */
    contactNumbers_numberInternationalFormat_con?: string | null;
    /** ContactNumbers.NumberInternationalFormat regex */
    contactNumbers_numberInternationalFormat_reg?: string | null;
    /** ContactNumbers.Label equals */
    contactNumbers_label_eq?: string | null;
    /** ContactNumbers.Label contains */
    contactNumbers_label_con?: string | null;
    /** ContactNumbers.Label regex */
    contactNumbers_label_reg?: string | null;
    /** ContactEmails.SearchIndex equals */
    contactEmails_searchIndex_eq?: string | null;
    /** ContactEmails.SearchIndex contains */
    contactEmails_searchIndex_con?: string | null;
    /** ContactEmails.SearchIndex regex */
    contactEmails_searchIndex_reg?: string | null;
    /** ContactEmails.Email equals */
    contactEmails_email_eq?: string | null;
    /** ContactEmails.Email contains */
    contactEmails_email_con?: string | null;
    /** ContactEmails.Email regex */
    contactEmails_email_reg?: string | null;
    /** ContactEmails.Label equals */
    contactEmails_label_eq?: string | null;
    /** ContactEmails.Label contains */
    contactEmails_label_con?: string | null;
    /** ContactEmails.Label regex */
    contactEmails_label_reg?: string | null;
    /** MailingAddresses.RecipientName equals */
    mailingAddresses_recipientName_eq?: string | null;
    /** MailingAddresses.RecipientName contains */
    mailingAddresses_recipientName_con?: string | null;
    /** MailingAddresses.RecipientName regex */
    mailingAddresses_recipientName_reg?: string | null;
    /** MailingAddresses.BusinessName equals */
    mailingAddresses_businessName_eq?: string | null;
    /** MailingAddresses.BusinessName contains */
    mailingAddresses_businessName_con?: string | null;
    /** MailingAddresses.BusinessName regex */
    mailingAddresses_businessName_reg?: string | null;
    /** MailingAddresses.StreetAddress equals */
    mailingAddresses_streetAddress_eq?: string | null;
    /** MailingAddresses.StreetAddress contains */
    mailingAddresses_streetAddress_con?: string | null;
    /** MailingAddresses.StreetAddress regex */
    mailingAddresses_streetAddress_reg?: string | null;
    /** MailingAddresses.ApparmentOrSuiteNumber equals */
    mailingAddresses_apparmentOrSuiteNumber_eq?: string | null;
    /** MailingAddresses.ApparmentOrSuiteNumber contains */
    mailingAddresses_apparmentOrSuiteNumber_con?: string | null;
    /** MailingAddresses.ApparmentOrSuiteNumber regex */
    mailingAddresses_apparmentOrSuiteNumber_reg?: string | null;
    /** MailingAddresses.City equals */
    mailingAddresses_city_eq?: string | null;
    /** MailingAddresses.City contains */
    mailingAddresses_city_con?: string | null;
    /** MailingAddresses.City regex */
    mailingAddresses_city_reg?: string | null;
    /** MailingAddresses.State equals */
    mailingAddresses_state_eq?: string | null;
    /** MailingAddresses.State contains */
    mailingAddresses_state_con?: string | null;
    /** MailingAddresses.State regex */
    mailingAddresses_state_reg?: string | null;
    /** MailingAddresses.ZipCode equals */
    mailingAddresses_zipCode_eq?: string | null;
    /** MailingAddresses.ZipCode contains */
    mailingAddresses_zipCode_con?: string | null;
    /** MailingAddresses.ZipCode regex */
    mailingAddresses_zipCode_reg?: string | null;
    /** MailingAddresses.Country equals */
    mailingAddresses_country_eq?: string | null;
    /** MailingAddresses.Country contains */
    mailingAddresses_country_con?: string | null;
    /** MailingAddresses.Country regex */
    mailingAddresses_country_reg?: string | null;
    /** FirstName equals */
    firstName_eq?: string | null;
    /** FirstName contains */
    firstName_con?: string | null;
    /** FirstName regex */
    firstName_reg?: string | null;
    /** LastName equals */
    lastName_eq?: string | null;
    /** LastName contains */
    lastName_con?: string | null;
    /** LastName regex */
    lastName_reg?: string | null;
    /** JobTitle equals */
    jobTitle_eq?: string | null;
    /** JobTitle contains */
    jobTitle_con?: string | null;
    /** JobTitle regex */
    jobTitle_reg?: string | null;
    /** Company equals */
    company_eq?: string | null;
    /** Company contains */
    company_con?: string | null;
    /** Company regex */
    company_reg?: string | null;
    /** Notes equals */
    notes_eq?: string | null;
    /** Notes contains */
    notes_con?: string | null;
    /** Notes regex */
    notes_reg?: string | null;
    /** Variables.Name equals */
    variables_name_eq?: string | null;
    /** Variables.Name contains */
    variables_name_con?: string | null;
    /** Variables.Name regex */
    variables_name_reg?: string | null;
    /** Variables.Value equals */
    variables_value_eq?: string | null;
    /** Variables.Value contains */
    variables_value_con?: string | null;
    /** Variables.Value regex */
    variables_value_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Contact phone number */
export interface ContactNumber {
    /** Phone number, Fax number, or any */
    number?: string;
    /** Phone number normalized in national format. This is needed so that searches are faster.
db.GlobalContacts.createIndex({"PhoneNumbers.PhoneNumberNormalized":1}) */
    numberInternationalFormat?: string | null;
    label?: LabelNumberType;
}

/** Contact */
export interface ContactUpdateRequest {
    /** Phone numbers of contact
Key = phone number
Value = type (example = work) */
    contactNumbers?: ContactNumber[] | null;
    /** Email addresses of contact */
    contactEmails?: ContactEmail[] | null;
    /** Mailing Addresses of contact */
    mailingAddresses?: MailingAddress[] | null;
    /** Contact first name */
    firstName?: string | null;
    /** Contact last name */
    lastName?: string | null;
    /** Contact job tittle */
    jobTitle?: string | null;
    company?: string | null;
    /** Contact Notes */
    notes?: string | null;
    /** Customer custom data */
    variables?: Variable[] | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Remember there is an ALL flag and also Unknown // :Geo-Permissions https://www.nationsonline.org/oneworld/country_code_list.htm */
export enum CountryIsoCode {
    None = "None",
    US = "US",
    RU = "RU",
    EG = "EG",
    ZA = "ZA",
    GR = "GR",
    NL = "NL",
    BE = "BE",
    FR = "FR",
    ES = "ES",
    HU = "HU",
    IT = "IT",
    RO = "RO",
    CH = "CH",
    AT = "AT",
    GB = "GB",
    DK = "DK",
    SE = "SE",
    NO = "NO",
    PL = "PL",
    DE = "DE",
    PE = "PE",
    MX = "MX",
    CU = "CU",
    AR = "AR",
    BR = "BR",
    CL = "CL",
    CO = "CO",
    VE = "VE",
    MY = "MY",
    AU = "AU",
    ID = "ID",
    PH = "PH",
    NZ = "NZ",
    SG = "SG",
    TH = "TH",
    JP = "JP",
    KR = "KR",
    VN = "VN",
    CN = "CN",
    TR = "TR",
    IN = "IN",
    PK = "PK",
    AF = "AF",
    LK = "LK",
    MM = "MM",
    IR = "IR",
    SS = "SS",
    MA = "MA",
    DZ = "DZ",
    TN = "TN",
    LY = "LY",
    GM = "GM",
    SN = "SN",
    MR = "MR",
    ML = "ML",
    GN = "GN",
    CI = "CI",
    BF = "BF",
    NE = "NE",
    TG = "TG",
    BJ = "BJ",
    MU = "MU",
    LR = "LR",
    SL = "SL",
    GH = "GH",
    NG = "NG",
    TD = "TD",
    CF = "CF",
    CM = "CM",
    CV = "CV",
    ST = "ST",
    GQ = "GQ",
    GA = "GA",
    CG = "CG",
    CD = "CD",
    AO = "AO",
    GW = "GW",
    IO = "IO",
    SC = "SC",
    SD = "SD",
    RW = "RW",
    ET = "ET",
    SO = "SO",
    DJ = "DJ",
    KE = "KE",
    TZ = "TZ",
    UG = "UG",
    BI = "BI",
    MZ = "MZ",
    ZM = "ZM",
    MG = "MG",
    YT = "YT",
    ZW = "ZW",
    NA = "NA",
    MW = "MW",
    LS = "LS",
    BW = "BW",
    SZ = "SZ",
    KM = "KM",
    SH = "SH",
    ER = "ER",
    AW = "AW",
    FO = "FO",
    GL = "GL",
    GI = "GI",
    PT = "PT",
    LU = "LU",
    IE = "IE",
    IS = "IS",
    AL = "AL",
    MT = "MT",
    CY = "CY",
    FI = "FI",
    BG = "BG",
    LT = "LT",
    LV = "LV",
    EE = "EE",
    MD = "MD",
    AM = "AM",
    BY = "BY",
    AD = "AD",
    MC = "MC",
    SM = "SM",
    VA = "VA",
    UA = "UA",
    RS = "RS",
    ME = "ME",
    XK = "XK",
    HR = "HR",
    SI = "SI",
    BA = "BA",
    MK = "MK",
    CZ = "CZ",
    SK = "SK",
    LI = "LI",
    FK = "FK",
    BZ = "BZ",
    GT = "GT",
    SV = "SV",
    HN = "HN",
    NI = "NI",
    CR = "CR",
    PA = "PA",
    PM = "PM",
    HT = "HT",
    BL = "BL",
    BO = "BO",
    GY = "GY",
    EC = "EC",
    PY = "PY",
    SR = "SR",
    UY = "UY",
    CW = "CW",
    TL = "TL",
    AQ = "AQ",
    BN = "BN",
    NR = "NR",
    PG = "PG",
    TO = "TO",
    SB = "SB",
    VU = "VU",
    FJ = "FJ",
    PW = "PW",
    WF = "WF",
    CK = "CK",
    NU = "NU",
    WS = "WS",
    KI = "KI",
    NC = "NC",
    TV = "TV",
    PF = "PF",
    TK = "TK",
    FM = "FM",
    MH = "MH",
    KP = "KP",
    HK = "HK",
    MO = "MO",
    KH = "KH",
    LA = "LA",
    BD = "BD",
    TW = "TW",
    MV = "MV",
    LB = "LB",
    JO = "JO",
    SY = "SY",
    IQ = "IQ",
    KW = "KW",
    SA = "SA",
    YE = "YE",
    OM = "OM",
    PS = "PS",
    AE = "AE",
    IL = "IL",
    BH = "BH",
    QA = "QA",
    BT = "BT",
    MN = "MN",
    NP = "NP",
    TJ = "TJ",
    TM = "TM",
    AZ = "AZ",
    GE = "GE",
    KG = "KG",
    UZ = "UZ",
    BS = "BS",
    BB = "BB",
    AI = "AI",
    AG = "AG",
    VG = "VG",
    VI = "VI",
    KY = "KY",
    BM = "BM",
    GD = "GD",
    TC = "TC",
    MS = "MS",
    MP = "MP",
    GU = "GU",
    AS = "AS",
    SX = "SX",
    LC = "LC",
    DM = "DM",
    VC = "VC",
    PR1 = "PR1",
    DO1 = "DO1",
    DO2 = "DO2",
    DO3 = "DO3",
    TT = "TT",
    KN = "KN",
    JM = "JM",
    PR2 = "PR2",
    GG = "GG",
    JE = "JE",
    IM = "IM",
    All = "All",
}

/** Needed because some providers like the one from Spain require customers info in order to purchase VoipNumber */
export interface CustomerInfo {
    /** Id of document */
    readonly id?: string;
    mailingAddress?: MailingAddress;
    airNetworksCustomerInfo?: AirNetworksCustomerInfo;
    /** Full legal name */
    fullName?: string;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for CustomerInfos */
export interface CustomerInfoFilterRequest {
    /** MailingAddress.RecipientName equals */
    mailingAddress_recipientName_eq?: string | null;
    /** MailingAddress.RecipientName contains */
    mailingAddress_recipientName_con?: string | null;
    /** MailingAddress.RecipientName regex */
    mailingAddress_recipientName_reg?: string | null;
    /** MailingAddress.BusinessName equals */
    mailingAddress_businessName_eq?: string | null;
    /** MailingAddress.BusinessName contains */
    mailingAddress_businessName_con?: string | null;
    /** MailingAddress.BusinessName regex */
    mailingAddress_businessName_reg?: string | null;
    /** MailingAddress.StreetAddress equals */
    mailingAddress_streetAddress_eq?: string | null;
    /** MailingAddress.StreetAddress contains */
    mailingAddress_streetAddress_con?: string | null;
    /** MailingAddress.StreetAddress regex */
    mailingAddress_streetAddress_reg?: string | null;
    /** MailingAddress.ApparmentOrSuiteNumber equals */
    mailingAddress_apparmentOrSuiteNumber_eq?: string | null;
    /** MailingAddress.ApparmentOrSuiteNumber contains */
    mailingAddress_apparmentOrSuiteNumber_con?: string | null;
    /** MailingAddress.ApparmentOrSuiteNumber regex */
    mailingAddress_apparmentOrSuiteNumber_reg?: string | null;
    /** MailingAddress.City equals */
    mailingAddress_city_eq?: string | null;
    /** MailingAddress.City contains */
    mailingAddress_city_con?: string | null;
    /** MailingAddress.City regex */
    mailingAddress_city_reg?: string | null;
    /** MailingAddress.State equals */
    mailingAddress_state_eq?: string | null;
    /** MailingAddress.State contains */
    mailingAddress_state_con?: string | null;
    /** MailingAddress.State regex */
    mailingAddress_state_reg?: string | null;
    /** MailingAddress.ZipCode equals */
    mailingAddress_zipCode_eq?: string | null;
    /** MailingAddress.ZipCode contains */
    mailingAddress_zipCode_con?: string | null;
    /** MailingAddress.ZipCode regex */
    mailingAddress_zipCode_reg?: string | null;
    /** MailingAddress.Country equals */
    mailingAddress_country_eq?: string | null;
    /** MailingAddress.Country contains */
    mailingAddress_country_con?: string | null;
    /** MailingAddress.Country regex */
    mailingAddress_country_reg?: string | null;
    /** AirNetworksCustomerInfo.IdNumber equals */
    airNetworksCustomerInfo_idNumber_eq?: string | null;
    /** AirNetworksCustomerInfo.IdNumber contains */
    airNetworksCustomerInfo_idNumber_con?: string | null;
    /** AirNetworksCustomerInfo.IdNumber regex */
    airNetworksCustomerInfo_idNumber_reg?: string | null;
    /** AirNetworksCustomerInfo.IdType equals */
    airNetworksCustomerInfo_idType_eq?: string | null;
    /** AirNetworksCustomerInfo.IdType contains */
    airNetworksCustomerInfo_idType_con?: string | null;
    /** AirNetworksCustomerInfo.IdType regex */
    airNetworksCustomerInfo_idType_reg?: string | null;
    /** AirNetworksCustomerInfo.Province equals */
    airNetworksCustomerInfo_province_eq?: string | null;
    /** AirNetworksCustomerInfo.Province contains */
    airNetworksCustomerInfo_province_con?: string | null;
    /** AirNetworksCustomerInfo.Province regex */
    airNetworksCustomerInfo_province_reg?: string | null;
    /** AirNetworksCustomerInfo.IdAirNetworksProvince equals */
    airNetworksCustomerInfo_idAirNetworksProvince_eq?: string | null;
    /** AirNetworksCustomerInfo.IdAirNetworksProvince contains */
    airNetworksCustomerInfo_idAirNetworksProvince_con?: string | null;
    /** AirNetworksCustomerInfo.IdAirNetworksProvince regex */
    airNetworksCustomerInfo_idAirNetworksProvince_reg?: string | null;
    /** AirNetworksCustomerInfo.Population equals */
    airNetworksCustomerInfo_population_eq?: string | null;
    /** AirNetworksCustomerInfo.Population contains */
    airNetworksCustomerInfo_population_con?: string | null;
    /** AirNetworksCustomerInfo.Population regex */
    airNetworksCustomerInfo_population_reg?: string | null;
    /** FullName equals */
    fullName_eq?: string | null;
    /** FullName contains */
    fullName_con?: string | null;
    /** FullName regex */
    fullName_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Needed because some providers like the one from Spain require customers info in order to purchase VoipNumber */
export interface CustomerInfoUpdateRequest {
    mailingAddress?: MailingAddress;
    /** Full legal name */
    fullName?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

export enum DayOfWeek {
    Sunday = "Sunday",
    Monday = "Monday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday",
    Thursday = "Thursday",
    Friday = "Friday",
    Saturday = "Saturday",
}

/** Email address. Two users may use the same email address */
export interface Email {
    /** Id of document */
    readonly id?: string;
    /** Email address */
    readonly address?: string;
    /** Date when email was verified */
    readonly dateVerified?: Date | null;
    sessionWhenVerified?: UbluxSession;
    /** Ip address where email was verified */
    readonly ipAddress?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for Emails */
export interface EmailFilterRequest {
    /** Address equals */
    address_eq?: string | null;
    /** Address contains */
    address_con?: string | null;
    /** Address regex */
    address_reg?: string | null;
    /** DateVerified equals */
    dateVerified_eq?: Date | null;
    /** DateVerified less than or equal to */
    dateVerified_lte?: Date | null;
    /** DateVerified greater than or equal to */
    dateVerified_gte?: Date | null;
    /** SessionWhenVerified.IdUser equals */
    sessionWhenVerified_idUser_eq?: string | null;
    /** SessionWhenVerified.IdUser contains */
    sessionWhenVerified_idUser_con?: string | null;
    /** SessionWhenVerified.IdUser regex */
    sessionWhenVerified_idUser_reg?: string | null;
    /** SessionWhenVerified.UserType equals */
    sessionWhenVerified_userType_eq?: string | null;
    /** SessionWhenVerified.UserType contains */
    sessionWhenVerified_userType_con?: string | null;
    /** SessionWhenVerified.UserType regex */
    sessionWhenVerified_userType_reg?: string | null;
    sessionWhenVerified_ubluxRoles_con?: UbluxRole;
    /** SessionWhenVerified.ExpirationDate equals */
    sessionWhenVerified_expirationDate_eq?: Date | null;
    /** SessionWhenVerified.ExpirationDate less than or equal to */
    sessionWhenVerified_expirationDate_lte?: Date | null;
    /** SessionWhenVerified.ExpirationDate greater than or equal to */
    sessionWhenVerified_expirationDate_gte?: Date | null;
    /** IpAddress equals */
    ipAddress_eq?: string | null;
    /** IpAddress contains */
    ipAddress_con?: string | null;
    /** IpAddress regex */
    ipAddress_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** EventAction to execute if a specific event occurs. For example if an extension is not answered send an email notification */
export interface EventAction {
    eventActionType?: EventActionType;
}

/** Forward call to another extension because call was not answered */
export interface EventActionForwardToExtension {
    eventActionType?: EventActionType;
    /** Extension where to forward call */
    idExtension?: string;
}

/** Forward call to a cell phone or land line because call was not answered */
export interface EventActionForwardToPhoneNumber {
    eventActionType?: EventActionType;
    /** Phone number where to forward the call */
    phoneNumber?: string;
}

/** Leave voicemail because call was not answered */
export interface EventActionLeaveVoicemail {
    eventActionType?: EventActionType;
    /** Emails where to send voicemails */
    idEmail?: string;
    /** Optional audio to play to instruct caller how to leave a voicemail. 
If not specified then a default audio will be played. 
The audio will say "Hello! You have reached the voicemail of ${NameOfExtension}. Please leave a detailed message after the beep. Thank you." */
    idAudio?: string | null;
}

/** Reason why an action executes */
export enum EventActionType {
    None = "None",
    ForwardToExtension = "ForwardToExtension",
    ForwardToPhoneNumber = "ForwardToPhoneNumber",
    LeaveVoicemail = "LeaveVoicemail",
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventCallPlacedOnHoldFor1Min */
export interface EventCallPlacedOnHoldFor1Min {
    eventTrigger?: EventTriggerType;
    /** Is the call incoming? If false call is outgiong */
    readonly isIncoming?: boolean;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Date when call was answered. If null it means it has not been answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact */
    readonly contactFullName?: string | null;
    /** If it is an incoming call then the id of line that answered the call.
If it is an outgiong call then the id of the line that initiated the call. */
    readonly lineId?: string;
    /** If it is an incoming call then the friendly name of the line that answered the call.
If it is an outgiong call then the friendly name of the line that initiated the call. */
    readonly lineFriendlyName?: string;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventCallPlacedOnHoldFor2Min */
export interface EventCallPlacedOnHoldFor2Min {
    eventTrigger?: EventTriggerType;
    /** Is the call incoming? If false call is outgiong */
    readonly isIncoming?: boolean;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Date when call was answered. If null it means it has not been answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact */
    readonly contactFullName?: string | null;
    /** If it is an incoming call then the id of line that answered the call.
If it is an outgiong call then the id of the line that initiated the call. */
    readonly lineId?: string;
    /** If it is an incoming call then the friendly name of the line that answered the call.
If it is an outgiong call then the friendly name of the line that initiated the call. */
    readonly lineFriendlyName?: string;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventCallPlacedOnHoldFor4Min */
export interface EventCallPlacedOnHoldFor4Min {
    eventTrigger?: EventTriggerType;
    /** Is the call incoming? If false call is outgiong */
    readonly isIncoming?: boolean;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Date when call was answered. If null it means it has not been answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact */
    readonly contactFullName?: string | null;
    /** If it is an incoming call then the id of line that answered the call.
If it is an outgiong call then the id of the line that initiated the call. */
    readonly lineId?: string;
    /** If it is an incoming call then the friendly name of the line that answered the call.
If it is an outgiong call then the friendly name of the line that initiated the call. */
    readonly lineFriendlyName?: string;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventCallPlacedOnHoldFor8Min */
export interface EventCallPlacedOnHoldFor8Min {
    eventTrigger?: EventTriggerType;
    /** Is the call incoming? If false call is outgiong */
    readonly isIncoming?: boolean;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Date when call was answered. If null it means it has not been answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact */
    readonly contactFullName?: string | null;
    /** If it is an incoming call then the id of line that answered the call.
If it is an outgiong call then the id of the line that initiated the call. */
    readonly lineId?: string;
    /** If it is an incoming call then the friendly name of the line that answered the call.
If it is an outgiong call then the friendly name of the line that initiated the call. */
    readonly lineFriendlyName?: string;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventExtensionNotAnswered */
export interface EventExtensionNotAnswered {
    eventTrigger?: EventTriggerType;
    /** Extension friendly name */
    readonly friendlyName?: string;
    /** Extension number */
    readonly number?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact that made phone call */
    readonly contactFullName?: string | null;
    /** How long extension ring? */
    readonly numberOfSecondsItRing?: number;
    /** Id of lines that ring */
    readonly linesThatRingIds?: string[];
    /** Id of lines that ring dit not ring */
    readonly linesThatDidNotRingIds?: string[];
    /** Name of lines that ring */
    readonly linesThatRingFriendlyNames?: string[];
    /** Name of lines that ring dit not ring */
    readonly linesThatDidNotRingFriendlyNames?: string[];
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventExtensionTookLongerThan1MinToBeAnswered */
export interface EventExtensionTookLongerThan1MinToBeAnswered {
    eventTrigger?: EventTriggerType;
    /** Extension friendly name */
    readonly friendlyName?: string;
    /** Extension number */
    readonly number?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact that made phone call */
    readonly contactFullName?: string | null;
    /** How long extension ring? */
    readonly numberOfSecondsItRing?: number;
    /** Id of lines that ring */
    readonly linesThatRingIds?: string[];
    /** Id of lines that ring dit not ring */
    readonly linesThatDidNotRingIds?: string[];
    /** Name of lines that ring */
    readonly linesThatRingFriendlyNames?: string[];
    /** Name of lines that ring dit not ring */
    readonly linesThatDidNotRingFriendlyNames?: string[];
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventExtensionTookLongerThan2MinToBeAnswered */
export interface EventExtensionTookLongerThan2MinToBeAnswered {
    eventTrigger?: EventTriggerType;
    /** Extension friendly name */
    readonly friendlyName?: string;
    /** Extension number */
    readonly number?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact that made phone call */
    readonly contactFullName?: string | null;
    /** How long extension ring? */
    readonly numberOfSecondsItRing?: number;
    /** Id of lines that ring */
    readonly linesThatRingIds?: string[];
    /** Id of lines that ring dit not ring */
    readonly linesThatDidNotRingIds?: string[];
    /** Name of lines that ring */
    readonly linesThatRingFriendlyNames?: string[];
    /** Name of lines that ring dit not ring */
    readonly linesThatDidNotRingFriendlyNames?: string[];
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventExtensionTookLongerThan4MinToBeAnswered */
export interface EventExtensionTookLongerThan4MinToBeAnswered {
    eventTrigger?: EventTriggerType;
    /** Extension friendly name */
    readonly friendlyName?: string;
    /** Extension number */
    readonly number?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact that made phone call */
    readonly contactFullName?: string | null;
    /** How long extension ring? */
    readonly numberOfSecondsItRing?: number;
    /** Id of lines that ring */
    readonly linesThatRingIds?: string[];
    /** Id of lines that ring dit not ring */
    readonly linesThatDidNotRingIds?: string[];
    /** Name of lines that ring */
    readonly linesThatRingFriendlyNames?: string[];
    /** Name of lines that ring dit not ring */
    readonly linesThatDidNotRingFriendlyNames?: string[];
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventExtensionTookLongerThan8MinToBeAnswered */
export interface EventExtensionTookLongerThan8MinToBeAnswered {
    eventTrigger?: EventTriggerType;
    /** Extension friendly name */
    readonly friendlyName?: string;
    /** Extension number */
    readonly number?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** Id of contact that made phone call */
    readonly contactId?: string | null;
    /** Name of contact that made phone call */
    readonly contactFullName?: string | null;
    /** How long extension ring? */
    readonly numberOfSecondsItRing?: number;
    /** Id of lines that ring */
    readonly linesThatRingIds?: string[];
    /** Id of lines that ring dit not ring */
    readonly linesThatDidNotRingIds?: string[];
    /** Name of lines that ring */
    readonly linesThatRingFriendlyNames?: string[];
    /** Name of lines that ring dit not ring */
    readonly linesThatDidNotRingFriendlyNames?: string[];
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventIncomingCallStarted */
export interface EventIncomingCallStarted {
    eventTrigger?: EventTriggerType;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventIncomingCallTerminated */
export interface EventIncomingCallTerminated {
    eventTrigger?: EventTriggerType;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** Date when call was ended */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventIncomingCallTerminatedWithAiAnalysis */
export interface EventIncomingCallTerminatedWithAiAnalysis {
    eventTrigger?: EventTriggerType;
    aiCallAnalysis?: AiCallAnalysisOutput;
    /** Recording of call */
    readonly recordingUrl?: string;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** Date when call was ended */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventIncomingCallTerminatedWithRecording */
export interface EventIncomingCallTerminatedWithRecording {
    eventTrigger?: EventTriggerType;
    /** Recording of call */
    readonly recordingUrl?: string;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** Date when call was ended */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventIncomingCallTerminatedWithTranscription */
export interface EventIncomingCallTerminatedWithTranscription {
    eventTrigger?: EventTriggerType;
    /** If there is a language it means there is a transcription */
    readonly transcriptionLanguage?: string | null;
    /** Audio of agent converted to text */
    readonly transcription?: AiTranscription[];
    /** Recording of call */
    readonly recordingUrl?: string;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** Date when call was ended */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventLineConnected */
export interface EventLineConnected {
    eventTrigger?: EventTriggerType;
    /** Line friendly name */
    readonly friendlyName?: string | null;
    /** Id of phone */
    readonly phoneId?: string | null;
    /** Name of phone */
    readonly phoneFriendly?: string | null;
    /** To what extension this line belongs */
    readonly extensionFriendlyName?: string | null;
    /** To what id extension this line belongs too */
    readonly extensionId?: string | null;
    /** To what extension number this line belongs too */
    readonly extensionNumber?: string | null;
    connectionStatus?: LineConnectionStatus;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventLineDisconnected */
export interface EventLineDisconnected {
    eventTrigger?: EventTriggerType;
    /** Line friendly name */
    readonly friendlyName?: string | null;
    /** Id of phone */
    readonly phoneId?: string | null;
    /** Name of phone */
    readonly phoneFriendly?: string | null;
    /** To what extension this line belongs */
    readonly extensionFriendlyName?: string | null;
    /** To what id extension this line belongs too */
    readonly extensionId?: string | null;
    /** To what extension number this line belongs too */
    readonly extensionNumber?: string | null;
    connectionStatus?: LineConnectionStatus;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventOutgoingCallStarted */
export interface EventOutgoingCallStarted {
    eventTrigger?: EventTriggerType;
    /** Id of line that initiated phone call */
    readonly lineThatInitiatedCallId?: string;
    /** Friendly name of line that initiated phone call */
    readonly lineThatInitiatedCallFrienlyName?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventOutgoingCallTerminated */
export interface EventOutgoingCallTerminated {
    eventTrigger?: EventTriggerType;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** How long call lasted in seconds */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Id of line that initiated phone call */
    readonly lineThatInitiatedCallId?: string;
    /** Friendly name of line that initiated phone call */
    readonly lineThatInitiatedCallFrienlyName?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventOutgoingCallTerminatedWithAiAnalysis */
export interface EventOutgoingCallTerminatedWithAiAnalysis {
    eventTrigger?: EventTriggerType;
    aiCallAnalysis?: AiCallAnalysisOutput;
    /** Recording of call */
    readonly recordingUrl?: string;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** How long call lasted in seconds */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Id of line that initiated phone call */
    readonly lineThatInitiatedCallId?: string;
    /** Friendly name of line that initiated phone call */
    readonly lineThatInitiatedCallFrienlyName?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventOutgoingCallTerminatedWithRecording */
export interface EventOutgoingCallTerminatedWithRecording {
    eventTrigger?: EventTriggerType;
    /** Recording of call */
    readonly recordingUrl?: string;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** How long call lasted in seconds */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Id of line that initiated phone call */
    readonly lineThatInitiatedCallId?: string;
    /** Friendly name of line that initiated phone call */
    readonly lineThatInitiatedCallFrienlyName?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Webhook will send this data when triggered. Ublux.Communications.Enums.EventTriggerType.EventOutgoingCallTerminatedWithTranscription */
export interface EventOutgoingCallTerminatedWithTranscription {
    eventTrigger?: EventTriggerType;
    /** If there is a language it means there is a transcription */
    readonly transcriptionLanguage?: string | null;
    /** Audio of agent converted to text */
    readonly transcription?: AiTranscription[];
    /** Recording of call */
    readonly recordingUrl?: string;
    /** Date when call was answered */
    readonly secondsItTookToAnswer?: number | null;
    /** Id of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredId?: string | null;
    /** Friendly name of line that answered in case it is an outgoing call to an extension */
    readonly lineThatAnsweredFrienlyName?: string | null;
    /** How long call lasted in seconds */
    readonly durationInSeconds?: number;
    /** Times when call was placed on hold */
    readonly timesWhenCallPlacedOnHold?: TimeWhenCallPlacedOnHold[];
    /** Id of line that initiated phone call */
    readonly lineThatInitiatedCallId?: string;
    /** Friendly name of line that initiated phone call */
    readonly lineThatInitiatedCallFrienlyName?: string;
    /** From phone number */
    readonly from?: string;
    /** To phone number */
    readonly to?: string;
    /** Date when call started */
    readonly dateStart?: Date;
    /** If call is incoming then the contact that made phone call.
If call is outgoing then the contact that we are calling. */
    readonly contactId?: string | null;
    /** If call is incoming then the name of contact that made phone call.
If call is outgoing then the name of contact that we are calling. */
    readonly contactFullName?: string | null;
    callErrors?: CallErrors;
    /** Id of document */
    id?: string;
}

/** Type of events that could trigger a custom action. Used by Zapier and Integromat */
export enum EventTriggerType {
    None = "None",
    EventOutgoingCallTerminated = "EventOutgoingCallTerminated",
    EventIncomingCallTerminated = "EventIncomingCallTerminated",
    EventOutgoingCallTerminatedWithRecording = "EventOutgoingCallTerminatedWithRecording",
    EventIncomingCallTerminatedWithRecording = "EventIncomingCallTerminatedWithRecording",
    EventOutgoingCallStarted = "EventOutgoingCallStarted",
    EventIncomingCallStarted = "EventIncomingCallStarted",
    EventOutgoingCallTerminatedWithTranscription = "EventOutgoingCallTerminatedWithTranscription",
    EventIncomingCallTerminatedWithTranscription = "EventIncomingCallTerminatedWithTranscription",
    EventOutgoingCallTerminatedWithAiAnalysis = "EventOutgoingCallTerminatedWithAiAnalysis",
    EventIncomingCallTerminatedWithAiAnalysis = "EventIncomingCallTerminatedWithAiAnalysis",
    EventCallPlacedOnHoldFor1Min = "EventCallPlacedOnHoldFor1Min",
    EventCallPlacedOnHoldFor2Min = "EventCallPlacedOnHoldFor2Min",
    EventCallPlacedOnHoldFor4Min = "EventCallPlacedOnHoldFor4Min",
    EventCallPlacedOnHoldFor8Min = "EventCallPlacedOnHoldFor8Min",
    EventLineDisconnected = "EventLineDisconnected",
    EventLineConnected = "EventLineConnected",
    EventExtensionNotAnswered = "EventExtensionNotAnswered",
    EventExtensionTookLongerThan1MinToBeAnswered = "EventExtensionTookLongerThan1MinToBeAnswered",
    EventExtensionTookLongerThan2MinToBeAnswered = "EventExtensionTookLongerThan2MinToBeAnswered",
    EventExtensionTookLongerThan4MinToBeAnswered = "EventExtensionTookLongerThan4MinToBeAnswered",
    EventExtensionTookLongerThan8MinToBeAnswered = "EventExtensionTookLongerThan8MinToBeAnswered",
}

/** Extension could be of type basic,queue,conference,voicemail or callFlowLogic */
export interface Extension {
    /** Id of document */
    readonly id?: string;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    extensionType?: ExtensionType;
    /** Extension friendly name */
    friendlyName?: string;
    /** Extension number */
    number?: string;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Executes a custom IVR when calling this extension */
export interface ExtensionCallFlowLogic {
    /** Id of document */
    readonly id?: string;
    /** Id of call flow to execute */
    idCallFlowLogic?: string;
    /** Optional label to jump to on the call flow? */
    callFlowLabel?: string | null;
    /** Execute call flow with this timezone. 
This is important if you have the IfBusinessHours node in the call flow for example. */
    timeZone?: string | null;
    extensionType?: ExtensionType;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string;
    /** Extension number */
    number?: string;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for ExtensionCallFlowLogics */
export interface ExtensionCallFlowLogicFilterRequest {
    /** IdCallFlowLogic equals */
    idCallFlowLogic_eq?: string | null;
    /** IdCallFlowLogic contains */
    idCallFlowLogic_con?: string | null;
    /** IdCallFlowLogic regex */
    idCallFlowLogic_reg?: string | null;
    /** CallFlowLabel equals */
    callFlowLabel_eq?: string | null;
    /** CallFlowLabel contains */
    callFlowLabel_con?: string | null;
    /** CallFlowLabel regex */
    callFlowLabel_reg?: string | null;
    /** TimeZone equals */
    timeZone_eq?: string | null;
    /** TimeZone contains */
    timeZone_con?: string | null;
    /** TimeZone regex */
    timeZone_reg?: string | null;
    /** ExtensionType equals */
    extensionType_eq?: string | null;
    /** ExtensionType contains */
    extensionType_con?: string | null;
    /** ExtensionType regex */
    extensionType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** InjectExtensionNameToCallerId equals */
    injectExtensionNameToCallerId_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Executes a custom IVR when calling this extension */
export interface ExtensionCallFlowLogicUpdateRequest {
    /** Id of call flow to execute */
    idCallFlowLogic?: string | null;
    /** Optional label to jump to on the call flow? */
    callFlowLabel?: string | null;
    /** Execute call flow with this timezone.
This is important if you have the IfBusinessHours node in the call flow for example. */
    timeZone?: string | null;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string | null;
    /** Extension number */
    number?: string | null;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Parties that dial this extension will be connected */
export interface ExtensionConference {
    /** Id of document */
    readonly id?: string;
    /** Optional audio to hear when the first participant enters the conference */
    idsAudiosWhenOneParticipant?: string[];
    /** Announce to everyone on the conference when a new participant enters the conference */
    announceParticipants?: boolean;
    /** Optional pin may be required to avoid unauthorized access to the conference
Pin is of type string because value could be 0000 and that would translate to 0 as an integer */
    pin?: string | null;
    extensionType?: ExtensionType;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string;
    /** Extension number */
    number?: string;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for ExtensionConferences */
export interface ExtensionConferenceFilterRequest {
    /** IdsAudiosWhenOneParticipant equals */
    idsAudiosWhenOneParticipant_eq?: string | null;
    /** IdsAudiosWhenOneParticipant contains */
    idsAudiosWhenOneParticipant_con?: string | null;
    /** IdsAudiosWhenOneParticipant regex */
    idsAudiosWhenOneParticipant_reg?: string | null;
    /** AnnounceParticipants equals */
    announceParticipants_eq?: boolean | null;
    /** Pin equals */
    pin_eq?: string | null;
    /** Pin contains */
    pin_con?: string | null;
    /** Pin regex */
    pin_reg?: string | null;
    /** ExtensionType equals */
    extensionType_eq?: string | null;
    /** ExtensionType contains */
    extensionType_con?: string | null;
    /** ExtensionType regex */
    extensionType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** InjectExtensionNameToCallerId equals */
    injectExtensionNameToCallerId_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Parties that dial this extension will be connected */
export interface ExtensionConferenceUpdateRequest {
    /** Optional audio to hear when the first participant enters the conference */
    idsAudiosWhenOneParticipant?: string[] | null;
    /** Announce to everyone on the conference when a new participant enters the conference */
    announceParticipants?: boolean | null;
    /** Optional pin may be required to avoid unauthorized access to the conference
Pin is of type string because value could be 0000 and that would translate to 0 as an integer */
    pin?: string | null;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string | null;
    /** Extension number */
    number?: string | null;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Basic extension */
export interface ExtensionDial {
    /** Id of document */
    readonly id?: string;
    /** Lines to call and ring. Minimum of one line is required */
    idsLines?: string[];
    eventActionToExecuteIfNotAnswered?: EventAction;
    sendEmailNotificationIfNotAnswered?: SendEmailNotificationIfNotAnswered;
    /** Number of seconds each line will ring */
    ringTimeInSeconds?: number;
    extensionType?: ExtensionType;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string;
    /** Extension number */
    number?: string;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for ExtensionDials */
export interface ExtensionDialFilterRequest {
    /** IdsLines equals */
    idsLines_eq?: string | null;
    /** IdsLines contains */
    idsLines_con?: string | null;
    /** IdsLines regex */
    idsLines_reg?: string | null;
    /** EventActionToExecuteIfNotAnswered.EventActionType equals */
    eventActionToExecuteIfNotAnswered_eventActionType_eq?: string | null;
    /** EventActionToExecuteIfNotAnswered.EventActionType contains */
    eventActionToExecuteIfNotAnswered_eventActionType_con?: string | null;
    /** EventActionToExecuteIfNotAnswered.EventActionType regex */
    eventActionToExecuteIfNotAnswered_eventActionType_reg?: string | null;
    /** SendEmailNotificationIfNotAnswered.IdsEmails equals */
    sendEmailNotificationIfNotAnswered_idsEmails_eq?: string | null;
    /** SendEmailNotificationIfNotAnswered.IdsEmails contains */
    sendEmailNotificationIfNotAnswered_idsEmails_con?: string | null;
    /** SendEmailNotificationIfNotAnswered.IdsEmails regex */
    sendEmailNotificationIfNotAnswered_idsEmails_reg?: string | null;
    /** SendEmailNotificationIfNotAnswered.PreventSendingNotificationIfLastLessThanNSeconds equals */
    sendEmailNotificationIfNotAnswered_preventSendingNotificationIfLastLessThanNSeconds_eq?: number | null;
    /** SendEmailNotificationIfNotAnswered.PreventSendingNotificationIfLastLessThanNSeconds less than or equal to */
    sendEmailNotificationIfNotAnswered_preventSendingNotificationIfLastLessThanNSeconds_lte?: number | null;
    /** SendEmailNotificationIfNotAnswered.PreventSendingNotificationIfLastLessThanNSeconds greater than or equal to */
    sendEmailNotificationIfNotAnswered_preventSendingNotificationIfLastLessThanNSeconds_gte?: number | null;
    /** RingTimeInSeconds equals */
    ringTimeInSeconds_eq?: number | null;
    /** RingTimeInSeconds less than or equal to */
    ringTimeInSeconds_lte?: number | null;
    /** RingTimeInSeconds greater than or equal to */
    ringTimeInSeconds_gte?: number | null;
    /** ExtensionType equals */
    extensionType_eq?: string | null;
    /** ExtensionType contains */
    extensionType_con?: string | null;
    /** ExtensionType regex */
    extensionType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** InjectExtensionNameToCallerId equals */
    injectExtensionNameToCallerId_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Basic extension */
export interface ExtensionDialUpdateRequest {
    /** Lines to call and ring. Minimum of one line is required */
    idsLines?: string[] | null;
    eventActionToExecuteIfNotAnswered?: EventAction;
    sendEmailNotificationIfNotAnswered?: SendEmailNotificationIfNotAnswered;
    /** Number of seconds each line will ring */
    ringTimeInSeconds?: number | null;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string | null;
    /** Extension number */
    number?: string | null;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Enables searching for Extensions */
export interface ExtensionFilterRequest {
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** ExtensionType equals */
    extensionType_eq?: string | null;
    /** ExtensionType contains */
    extensionType_con?: string | null;
    /** ExtensionType regex */
    extensionType_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** InjectExtensionNameToCallerId equals */
    injectExtensionNameToCallerId_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Extension where people that call will be placed on a sequence awaiting their turn to be attended */
export interface ExtensionQueue {
    /** Id of document */
    readonly id?: string;
    /** Audios to play meanwhile caller is waiting to be attended */
    idsAudios?: string[];
    sendEmailNotificationIfItTakesToLongToBeAnswered?: SendEmailNotificationIfItTakesToLongToBeAnswered;
    /** If line is busy do you still want it to ring it? */
    ringInUse?: boolean;
    /** Maximum amount of minutes a user can be waiting on the queue. */
    queueTimeoutInMinutes?: number;
    /** Play position announcements. For example say things like you are now position 2 in queue. There are 2 calls ahead of you. */
    announcePosition?: boolean;
    /** Play thinks like. Currently wait time is 2 minutes */
    announceHoldTime?: boolean;
    /** How often to announce stuff? */
    announceFrequency?: number;
    /** Number of seconds to wait in between rings. Default value if null is 20 seconds */
    retryFrequency?: number;
    ringStrategy?: QueueRingStrategy;
    extensionType?: ExtensionType;
    /** Lines to call and ring. Minimum of one line is required */
    idsLines?: string[];
    eventActionToExecuteIfNotAnswered?: EventAction;
    sendEmailNotificationIfNotAnswered?: SendEmailNotificationIfNotAnswered;
    /** Number of seconds each line will ring */
    ringTimeInSeconds?: number;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string;
    /** Extension number */
    number?: string;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for ExtensionQueues */
export interface ExtensionQueueFilterRequest {
    /** IdsAudios equals */
    idsAudios_eq?: string | null;
    /** IdsAudios contains */
    idsAudios_con?: string | null;
    /** IdsAudios regex */
    idsAudios_reg?: string | null;
    /** SendEmailNotificationIfItTakesToLongToBeAnswered.TimeInSeconds equals */
    sendEmailNotificationIfItTakesToLongToBeAnswered_timeInSeconds_eq?: number | null;
    /** SendEmailNotificationIfItTakesToLongToBeAnswered.TimeInSeconds less than or equal to */
    sendEmailNotificationIfItTakesToLongToBeAnswered_timeInSeconds_lte?: number | null;
    /** SendEmailNotificationIfItTakesToLongToBeAnswered.TimeInSeconds greater than or equal to */
    sendEmailNotificationIfItTakesToLongToBeAnswered_timeInSeconds_gte?: number | null;
    /** SendEmailNotificationIfItTakesToLongToBeAnswered.IdsEmails equals */
    sendEmailNotificationIfItTakesToLongToBeAnswered_idsEmails_eq?: string | null;
    /** SendEmailNotificationIfItTakesToLongToBeAnswered.IdsEmails contains */
    sendEmailNotificationIfItTakesToLongToBeAnswered_idsEmails_con?: string | null;
    /** SendEmailNotificationIfItTakesToLongToBeAnswered.IdsEmails regex */
    sendEmailNotificationIfItTakesToLongToBeAnswered_idsEmails_reg?: string | null;
    /** RingInUse equals */
    ringInUse_eq?: boolean | null;
    /** QueueTimeoutInMinutes equals */
    queueTimeoutInMinutes_eq?: number | null;
    /** QueueTimeoutInMinutes less than or equal to */
    queueTimeoutInMinutes_lte?: number | null;
    /** QueueTimeoutInMinutes greater than or equal to */
    queueTimeoutInMinutes_gte?: number | null;
    /** AnnouncePosition equals */
    announcePosition_eq?: boolean | null;
    /** AnnounceHoldTime equals */
    announceHoldTime_eq?: boolean | null;
    /** AnnounceFrequency equals */
    announceFrequency_eq?: number | null;
    /** AnnounceFrequency less than or equal to */
    announceFrequency_lte?: number | null;
    /** AnnounceFrequency greater than or equal to */
    announceFrequency_gte?: number | null;
    /** RetryFrequency equals */
    retryFrequency_eq?: number | null;
    /** RetryFrequency less than or equal to */
    retryFrequency_lte?: number | null;
    /** RetryFrequency greater than or equal to */
    retryFrequency_gte?: number | null;
    /** RingStrategy equals */
    ringStrategy_eq?: string | null;
    /** RingStrategy contains */
    ringStrategy_con?: string | null;
    /** RingStrategy regex */
    ringStrategy_reg?: string | null;
    /** ExtensionType equals */
    extensionType_eq?: string | null;
    /** ExtensionType contains */
    extensionType_con?: string | null;
    /** ExtensionType regex */
    extensionType_reg?: string | null;
    /** IdsLines equals */
    idsLines_eq?: string | null;
    /** IdsLines contains */
    idsLines_con?: string | null;
    /** IdsLines regex */
    idsLines_reg?: string | null;
    /** EventActionToExecuteIfNotAnswered.EventActionType equals */
    eventActionToExecuteIfNotAnswered_eventActionType_eq?: string | null;
    /** EventActionToExecuteIfNotAnswered.EventActionType contains */
    eventActionToExecuteIfNotAnswered_eventActionType_con?: string | null;
    /** EventActionToExecuteIfNotAnswered.EventActionType regex */
    eventActionToExecuteIfNotAnswered_eventActionType_reg?: string | null;
    /** SendEmailNotificationIfNotAnswered.IdsEmails equals */
    sendEmailNotificationIfNotAnswered_idsEmails_eq?: string | null;
    /** SendEmailNotificationIfNotAnswered.IdsEmails contains */
    sendEmailNotificationIfNotAnswered_idsEmails_con?: string | null;
    /** SendEmailNotificationIfNotAnswered.IdsEmails regex */
    sendEmailNotificationIfNotAnswered_idsEmails_reg?: string | null;
    /** SendEmailNotificationIfNotAnswered.PreventSendingNotificationIfLastLessThanNSeconds equals */
    sendEmailNotificationIfNotAnswered_preventSendingNotificationIfLastLessThanNSeconds_eq?: number | null;
    /** SendEmailNotificationIfNotAnswered.PreventSendingNotificationIfLastLessThanNSeconds less than or equal to */
    sendEmailNotificationIfNotAnswered_preventSendingNotificationIfLastLessThanNSeconds_lte?: number | null;
    /** SendEmailNotificationIfNotAnswered.PreventSendingNotificationIfLastLessThanNSeconds greater than or equal to */
    sendEmailNotificationIfNotAnswered_preventSendingNotificationIfLastLessThanNSeconds_gte?: number | null;
    /** RingTimeInSeconds equals */
    ringTimeInSeconds_eq?: number | null;
    /** RingTimeInSeconds less than or equal to */
    ringTimeInSeconds_lte?: number | null;
    /** RingTimeInSeconds greater than or equal to */
    ringTimeInSeconds_gte?: number | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** InjectExtensionNameToCallerId equals */
    injectExtensionNameToCallerId_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Extension where people that call will be placed on a sequence awaiting their turn to be attended */
export interface ExtensionQueueUpdateRequest {
    /** Audios to play meanwhile caller is waiting to be attended */
    idsAudios?: string[] | null;
    sendEmailNotificationIfItTakesToLongToBeAnswered?: SendEmailNotificationIfItTakesToLongToBeAnswered;
    /** If line is busy do you still want it to ring it? */
    ringInUse?: boolean | null;
    /** Maximum amount of minutes a user can be waiting on the queue. */
    queueTimeoutInMinutes?: number | null;
    /** Play position announcements. For example say things like you are now position 2 in queue. There are 2 calls ahead of you. */
    announcePosition?: boolean | null;
    /** Play thinks like. Currently wait time is 2 minutes */
    announceHoldTime?: boolean | null;
    /** How often to announce stuff? */
    announceFrequency?: number | null;
    /** Number of seconds to wait in between rings. Default value if null is 20 seconds */
    retryFrequency?: number | null;
    ringStrategy?: QueueRingStrategy;
    /** Lines to call and ring. Minimum of one line is required */
    idsLines?: string[] | null;
    eventActionToExecuteIfNotAnswered?: EventAction;
    sendEmailNotificationIfNotAnswered?: SendEmailNotificationIfNotAnswered;
    /** Number of seconds each line will ring */
    ringTimeInSeconds?: number | null;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string | null;
    /** Extension number */
    number?: string | null;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Type of extension */
export enum ExtensionType {
    None = "None",
    CallFlowLogic = "CallFlowLogic",
    Conference = "Conference",
    Dial = "Dial",
    Queue = "Queue",
    Voicemail = "Voicemail",
}

/** Calling this extension will enable to store a voicemail and be sent via email */
export interface ExtensionVoicemail {
    /** Id of document */
    readonly id?: string;
    /** Optional audio to play before leaving voicemail */
    idAudio?: string | null;
    /** Lines that can listen to this voicemail on their phones. It is also possible to listen to voicemails through phones and not just email. */
    idsLinesThatCanListenToVoicemail?: string[];
    /** Emails where to send the voicemail */
    idEmail?: string;
    /** This text will be converted to audio and be played before leaving voicemail */
    textToSpeech?: string | null;
    /** If using tts (text to speech) then what voice id to use with amazon? Joana? */
    textToSpeechVoiceId?: string | null;
    extensionType?: ExtensionType;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string;
    /** Extension number */
    number?: string;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for ExtensionVoicemails */
export interface ExtensionVoicemailFilterRequest {
    /** IdAudio equals */
    idAudio_eq?: string | null;
    /** IdAudio contains */
    idAudio_con?: string | null;
    /** IdAudio regex */
    idAudio_reg?: string | null;
    /** IdsLinesThatCanListenToVoicemail equals */
    idsLinesThatCanListenToVoicemail_eq?: string | null;
    /** IdsLinesThatCanListenToVoicemail contains */
    idsLinesThatCanListenToVoicemail_con?: string | null;
    /** IdsLinesThatCanListenToVoicemail regex */
    idsLinesThatCanListenToVoicemail_reg?: string | null;
    /** IdEmail equals */
    idEmail_eq?: string | null;
    /** IdEmail contains */
    idEmail_con?: string | null;
    /** IdEmail regex */
    idEmail_reg?: string | null;
    /** TextToSpeech equals */
    textToSpeech_eq?: string | null;
    /** TextToSpeech contains */
    textToSpeech_con?: string | null;
    /** TextToSpeech regex */
    textToSpeech_reg?: string | null;
    /** TextToSpeechVoiceId equals */
    textToSpeechVoiceId_eq?: string | null;
    /** TextToSpeechVoiceId contains */
    textToSpeechVoiceId_con?: string | null;
    /** TextToSpeechVoiceId regex */
    textToSpeechVoiceId_reg?: string | null;
    /** ExtensionType equals */
    extensionType_eq?: string | null;
    /** ExtensionType contains */
    extensionType_con?: string | null;
    /** ExtensionType regex */
    extensionType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** InjectExtensionNameToCallerId equals */
    injectExtensionNameToCallerId_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Calling this extension will enable to store a voicemail and be sent via email */
export interface ExtensionVoicemailUpdateRequest {
    /** Optional audio to play before leaving voicemail */
    idAudio?: string | null;
    /** Lines that can listen to this voicemail on their phones. It is also possible to listen to voicemails through phones and not just email. */
    idsLinesThatCanListenToVoicemail?: string[] | null;
    /** Emails where to send the voicemail */
    idEmail?: string | null;
    /** This text will be converted to audio and be played before leaving voicemail */
    textToSpeech?: string | null;
    /** If using tts (text to speech) then what voice id to use with amazon? Joana? */
    textToSpeechVoiceId?: string | null;
    /** Music on hold to use */
    idMusicOnHoldGroup?: string | null;
    /** Extension friendly name */
    friendlyName?: string | null;
    /** Extension number */
    number?: string | null;
    /** Inject extension name to caller id */
    injectExtensionNameToCallerId?: boolean | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Incoming fax */
export interface FaxIncoming {
    /** Id of document */
    readonly id?: string;
    /** Received fax from this VOIP number. This could also be named the 'To' property. */
    readonly idVoipNumberFax?: string;
    /** Contact */
    readonly idContact?: string | null;
    pdf?: StoredFile;
    /** Number of pages received */
    readonly numPages?: number;
    /** Status of fax */
    readonly faxStatus?: string;
    /** Fax number of sender */
    readonly from?: string;
    /** Fax number that received the fax */
    readonly to?: string;
    /** Description of error if there is one */
    readonly errorMessage?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for FaxIncomings */
export interface FaxIncomingFilterRequest {
    /** IdVoipNumberFax equals */
    idVoipNumberFax_eq?: string | null;
    /** IdVoipNumberFax contains */
    idVoipNumberFax_con?: string | null;
    /** IdVoipNumberFax regex */
    idVoipNumberFax_reg?: string | null;
    /** IdContact equals */
    idContact_eq?: string | null;
    /** IdContact contains */
    idContact_con?: string | null;
    /** IdContact regex */
    idContact_reg?: string | null;
    /** Pdf.InstanceId equals */
    pdf_instanceId_eq?: string | null;
    /** Pdf.InstanceId contains */
    pdf_instanceId_con?: string | null;
    /** Pdf.InstanceId regex */
    pdf_instanceId_reg?: string | null;
    /** Pdf.FileSizeInBytes equals */
    pdf_fileSizeInBytes_eq?: number | null;
    /** Pdf.FileSizeInBytes less than or equal to */
    pdf_fileSizeInBytes_lte?: number | null;
    /** Pdf.FileSizeInBytes greater than or equal to */
    pdf_fileSizeInBytes_gte?: number | null;
    /** Pdf.Md5Hash equals */
    pdf_md5Hash_eq?: string | null;
    /** Pdf.Md5Hash contains */
    pdf_md5Hash_con?: string | null;
    /** Pdf.Md5Hash regex */
    pdf_md5Hash_reg?: string | null;
    /** Pdf.Url equals */
    pdf_url_eq?: string | null;
    /** Pdf.Url contains */
    pdf_url_con?: string | null;
    /** Pdf.Url regex */
    pdf_url_reg?: string | null;
    /** Pdf.Id equals */
    pdf_id_eq?: string | null;
    /** Pdf.Id contains */
    pdf_id_con?: string | null;
    /** Pdf.Id regex */
    pdf_id_reg?: string | null;
    /** NumPages equals */
    numPages_eq?: number | null;
    /** NumPages less than or equal to */
    numPages_lte?: number | null;
    /** NumPages greater than or equal to */
    numPages_gte?: number | null;
    /** FaxStatus equals */
    faxStatus_eq?: string | null;
    /** FaxStatus contains */
    faxStatus_con?: string | null;
    /** FaxStatus regex */
    faxStatus_reg?: string | null;
    /** From equals */
    from_eq?: string | null;
    /** From contains */
    from_con?: string | null;
    /** From regex */
    from_reg?: string | null;
    /** To equals */
    to_eq?: string | null;
    /** To contains */
    to_con?: string | null;
    /** To regex */
    to_reg?: string | null;
    /** ErrorMessage equals */
    errorMessage_eq?: string | null;
    /** ErrorMessage contains */
    errorMessage_con?: string | null;
    /** ErrorMessage regex */
    errorMessage_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Incoming fax */
export interface FaxIncomingUpdateRequest {
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Outgoing fax */
export interface FaxOutgoing {
    /** Number of pages that Pdf contains */
    readonly numberOfPages?: number;
    /** Status of fax sent */
    readonly faxStatus?: string;
    /** Fax number to where fax was sent */
    readonly to?: string;
    /** Description of error */
    readonly errorMessage?: string | null;
    pdf?: StoredFile;
    /** Number of pages that where actually sent */
    readonly numberOfPagesSent?: number;
    /** Is pdf in portrait or landscape mode? */
    readonly isPortrait?: boolean | null;
    /** File name of attachment */
    readonly name?: string;
    /** Used in case the line is busy to retry again */
    readonly numberOfAttempts?: number;
    /** Id of entity */
    readonly id?: string;
}

/** Group of faxes sent as a group via email */
export interface FaxOutgoingGroup {
    /** Id of document */
    readonly id?: string;
    /** Id of Fax VoipNumber (virtual number) that sent the fax */
    readonly idVoipNumberFax?: string;
    /** There must be at least one fax attachment */
    readonly faxesOutgoing?: FaxOutgoing[];
    /** Phone number where fax is sent */
    readonly from?: string;
    /** If fax is sent successfully then send confirmation to this emails */
    readonly idsEmailsSendConfirmation?: string[];
    /** True if there is an error */
    readonly containsError?: boolean;
    status?: ProcessStatus;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for FaxOutgoingGroups */
export interface FaxOutgoingGroupFilterRequest {
    /** IdVoipNumberFax equals */
    idVoipNumberFax_eq?: string | null;
    /** IdVoipNumberFax contains */
    idVoipNumberFax_con?: string | null;
    /** IdVoipNumberFax regex */
    idVoipNumberFax_reg?: string | null;
    /** FaxesOutgoing.NumberOfPages equals */
    faxesOutgoing_numberOfPages_eq?: number | null;
    /** FaxesOutgoing.NumberOfPages less than or equal to */
    faxesOutgoing_numberOfPages_lte?: number | null;
    /** FaxesOutgoing.NumberOfPages greater than or equal to */
    faxesOutgoing_numberOfPages_gte?: number | null;
    /** FaxesOutgoing.FaxStatus equals */
    faxesOutgoing_faxStatus_eq?: string | null;
    /** FaxesOutgoing.FaxStatus contains */
    faxesOutgoing_faxStatus_con?: string | null;
    /** FaxesOutgoing.FaxStatus regex */
    faxesOutgoing_faxStatus_reg?: string | null;
    /** FaxesOutgoing.To equals */
    faxesOutgoing_to_eq?: string | null;
    /** FaxesOutgoing.To contains */
    faxesOutgoing_to_con?: string | null;
    /** FaxesOutgoing.To regex */
    faxesOutgoing_to_reg?: string | null;
    /** FaxesOutgoing.ErrorMessage equals */
    faxesOutgoing_errorMessage_eq?: string | null;
    /** FaxesOutgoing.ErrorMessage contains */
    faxesOutgoing_errorMessage_con?: string | null;
    /** FaxesOutgoing.ErrorMessage regex */
    faxesOutgoing_errorMessage_reg?: string | null;
    /** FaxesOutgoing.Pdf.InstanceId equals */
    faxesOutgoing_pdf_instanceId_eq?: string | null;
    /** FaxesOutgoing.Pdf.InstanceId contains */
    faxesOutgoing_pdf_instanceId_con?: string | null;
    /** FaxesOutgoing.Pdf.InstanceId regex */
    faxesOutgoing_pdf_instanceId_reg?: string | null;
    /** FaxesOutgoing.Pdf.FileSizeInBytes equals */
    faxesOutgoing_pdf_fileSizeInBytes_eq?: number | null;
    /** FaxesOutgoing.Pdf.FileSizeInBytes less than or equal to */
    faxesOutgoing_pdf_fileSizeInBytes_lte?: number | null;
    /** FaxesOutgoing.Pdf.FileSizeInBytes greater than or equal to */
    faxesOutgoing_pdf_fileSizeInBytes_gte?: number | null;
    /** FaxesOutgoing.Pdf.Md5Hash equals */
    faxesOutgoing_pdf_md5Hash_eq?: string | null;
    /** FaxesOutgoing.Pdf.Md5Hash contains */
    faxesOutgoing_pdf_md5Hash_con?: string | null;
    /** FaxesOutgoing.Pdf.Md5Hash regex */
    faxesOutgoing_pdf_md5Hash_reg?: string | null;
    /** FaxesOutgoing.Pdf.Url equals */
    faxesOutgoing_pdf_url_eq?: string | null;
    /** FaxesOutgoing.Pdf.Url contains */
    faxesOutgoing_pdf_url_con?: string | null;
    /** FaxesOutgoing.Pdf.Url regex */
    faxesOutgoing_pdf_url_reg?: string | null;
    /** FaxesOutgoing.Pdf.Id equals */
    faxesOutgoing_pdf_id_eq?: string | null;
    /** FaxesOutgoing.Pdf.Id contains */
    faxesOutgoing_pdf_id_con?: string | null;
    /** FaxesOutgoing.Pdf.Id regex */
    faxesOutgoing_pdf_id_reg?: string | null;
    /** FaxesOutgoing.NumberOfPagesSent equals */
    faxesOutgoing_numberOfPagesSent_eq?: number | null;
    /** FaxesOutgoing.NumberOfPagesSent less than or equal to */
    faxesOutgoing_numberOfPagesSent_lte?: number | null;
    /** FaxesOutgoing.NumberOfPagesSent greater than or equal to */
    faxesOutgoing_numberOfPagesSent_gte?: number | null;
    /** FaxesOutgoing.IsPortrait equals */
    faxesOutgoing_isPortrait_eq?: boolean | null;
    /** FaxesOutgoing.Name equals */
    faxesOutgoing_name_eq?: string | null;
    /** FaxesOutgoing.Name contains */
    faxesOutgoing_name_con?: string | null;
    /** FaxesOutgoing.Name regex */
    faxesOutgoing_name_reg?: string | null;
    /** FaxesOutgoing.NumberOfAttempts equals */
    faxesOutgoing_numberOfAttempts_eq?: number | null;
    /** FaxesOutgoing.NumberOfAttempts less than or equal to */
    faxesOutgoing_numberOfAttempts_lte?: number | null;
    /** FaxesOutgoing.NumberOfAttempts greater than or equal to */
    faxesOutgoing_numberOfAttempts_gte?: number | null;
    /** FaxesOutgoing.Id equals */
    faxesOutgoing_id_eq?: string | null;
    /** FaxesOutgoing.Id contains */
    faxesOutgoing_id_con?: string | null;
    /** FaxesOutgoing.Id regex */
    faxesOutgoing_id_reg?: string | null;
    /** From equals */
    from_eq?: string | null;
    /** From contains */
    from_con?: string | null;
    /** From regex */
    from_reg?: string | null;
    /** IdsEmailsSendConfirmation equals */
    idsEmailsSendConfirmation_eq?: string | null;
    /** IdsEmailsSendConfirmation contains */
    idsEmailsSendConfirmation_con?: string | null;
    /** IdsEmailsSendConfirmation regex */
    idsEmailsSendConfirmation_reg?: string | null;
    /** ContainsError equals */
    containsError_eq?: boolean | null;
    /** Status equals */
    status_eq?: string | null;
    /** Status contains */
    status_con?: string | null;
    /** Status regex */
    status_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Group of faxes sent as a group via email */
export interface FaxOutgoingGroupUpdateRequest {
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** A node in a call flow, sms flow or whatsapp flow */
export interface FlowNode {
    flowNodeType?: FlowNodeType;
}

export enum FlowNodeType {
    Say = "Say",
    Play = "Play",
    IfDigits = "IfDigits",
    Digits = "Digits",
    AnyDigits = "AnyDigits",
    IfTime = "IfTime",
    Time = "Time",
    AnyTime = "AnyTime",
    IfWeekDay = "IfWeekDay",
    WeekDays = "WeekDays",
    AnyWeekDay = "AnyWeekDay",
    Extension = "Extension",
    DynamicExtension = "DynamicExtension",
    IfLineOffline = "IfLineOffline",
    LineOnline = "LineOnline",
    LineOffline = "LineOffline",
    Call = "Call",
    Pause = "Pause",
    GoTo = "GoTo",
    Bookmark = "Bookmark",
    Comment = "Comment",
    API = "API",
    CallBackAPI = "CallBackAPI",
    Hangup = "Hangup",
}

/** When a user successfully authenticate this will be its values */
export interface HttpResponseAuthorization {
    /** Type of token */
    readonly token_type?: string | null;
    /** Access token */
    access_token?: string | null;
    /** Authenticated user roles */
    roles?: UbluxRole[] | null;
    /** Scope */
    scope?: string | null;
    /** Refresh token */
    refresh_token?: string | null;
    /** Expiration in seconds */
    expires_in?: number;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfAiCallAnalysisInput {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: AiCallAnalysisInput[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfAiCallTranscription {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: AiCallTranscription[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfApiKey {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: ApiKey[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfAudio {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Audio[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfBlackListPhoneNumber {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: BlackListPhoneNumber[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfCall {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Call[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfCallFlowLogic {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: CallFlowLogic[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfCallerIdMask {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: CallerIdMask[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfContact {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Contact[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfCustomerInfo {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: CustomerInfo[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfEmail {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Email[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfExtension {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Extension[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfExtensionCallFlowLogic {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: ExtensionCallFlowLogic[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfExtensionConference {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: ExtensionConference[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfExtensionDial {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: ExtensionDial[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfExtensionQueue {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: ExtensionQueue[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfExtensionVoicemail {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: ExtensionVoicemail[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfFaxIncoming {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: FaxIncoming[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfFaxOutgoingGroup {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: FaxOutgoingGroup[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfLineKeyGroup {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: LineKeyGroup[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfMusicOnHoldGroup {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: MusicOnHoldGroup[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfPhone {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Phone[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfPhoneConfiguration {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: PhoneConfiguration[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfPowerDialerGroup {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: PowerDialerGroup[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfSMS {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: SMS[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfTag {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Tag[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfUser {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: User[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfVoicemail {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: Voicemail[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfVoipNumber {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: VoipNumber[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfVoipNumberAvailableForPurchase {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: VoipNumberAvailableForPurchase[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfVoipNumberFax {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: VoipNumberFax[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfVoipNumberPhone {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: VoipNumberPhone[] | null;
}

/** Limits the number of results that can obtained per request. */
export interface HttpResponsePaginationResultOfWebHook {
    /** Page number */
    pageNumber?: number;
    /** Maximum number of records that can be retrieved per page */
    pageSize?: number;
    /** Number of records */
    readonly recordsCount?: number;
    /** Results */
    records?: WebHook[] | null;
}

/** UBLUX Web API will return this response when there are validation errors. */
export interface HttpResponseValidationErrorsResponse {
    traceId?: string | null;
    /** Description of validation errors containing the PropertyName, PropertyValue and ErrorMessage */
    validationErrors?: ValidationError[] | null;
    /** Message title */
    title?: string | null;
}

/** Sector */
export enum Industry {
    Other = "Other",
    Hotels = "Hotels",
    HR = "HR",
    Pharmacies = "Pharmacies",
    Restaurants = "Restaurants",
    Healthcare = "Healthcare",
    Finance = "Finance",
    Startups = "Startups",
    Edtech = "Edtech",
    Schools = "Schools",
    Ecommerce = "Ecommerce",
    Sports_Centers = "Sports_Centers",
    Insurances = "Insurances",
    Attorneys = "Attorneys",
    Call_Centers = "Call_Centers",
    Automotive = "Automotive",
}

/** Type of email address */
export enum LabelEmailType {
    Other = "Other",
    Home = "Home",
    Work = "Work",
}

/** Type of number */
export enum LabelNumberType {
    Other = "Other",
    Home = "Home",
    Work = "Work",
    Mobile = "Mobile",
    Main = "Main",
    HomeFax = "HomeFax",
    WorkFax = "WorkFax",
    Pager = "Pager",
}

/** Language */
export enum Language {
    None = "None",
    EN_US = "EN_US",
    EN_GB = "EN_GB",
    ES_ES = "ES_ES",
    ES_MX = "ES_MX",
}

/** It is part of a phone. Lines are needed in order to make and receive phone calls. */
export interface Line {
    friendlyName?: string;
    lineConnectionStatus?: LineConnectionStatus;
    /** Caller id number that will be used to place outbound calls */
    callerIdNumber?: string;
    /** Record outbound calls to PSTN? */
    recordExternalCalls?: boolean;
    /** Record calls to other extensions? */
    recordInternalCalls?: boolean;
    /** Users will be charged extra for AI transcriptions. If this is true external calls to PSTN will be recorded. */
    useAiForExternalCalls?: boolean;
    /** Users will be charged extra for AI transcriptions. If this is true internal calls to extensions will be recorded. */
    useAiForOutgoingCallsToExtensions?: boolean;
    /** What input to pass to AI engine. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    language?: Language;
    /** Id of entity */
    readonly id?: string;
}

/** BLF status of a line */
export interface LineBlfStatus {
    /** Id of line */
    idLine?: string;
    /** Id of channel */
    idChannel?: string;
    /** Extension called */
    callerId?: string | null;
    blfStatusType?: BlfStatusType;
}

/** Status of phone line */
export interface LineConnectionStatus {
    /** Public ip address of the connection */
    readonly ipWAN?: string | null;
    /** Public port */
    readonly portWAN?: number;
    /** Private ip address of the connection */
    readonly ipLAN?: string | null;
    /** Private port */
    readonly portLAN?: number;
    /** User agent of phone connecting */
    readonly userAgent?: string | null;
    /** Null means we do not know */
    readonly isConnected?: boolean | null;
    /** Reason of phone disconnected. 
Posible reasons: none, registration failure, remove existing, remove unavailable, expiration, request, shutdown */
    readonly disconnectedReason?: string | null;
    /** Date when line was last connected */
    readonly dateConnected?: Date | null;
    /** Date when line was last disconnected */
    readonly dateDisconnected?: Date | null;
}

/** Speed dial */
export interface LineKey {
    lineKeyType?: LineKeyType;
    /** Display name of line key */
    label?: string;
    /** Value of line key. Example: 9546543982
Only requried if LineKeyType is SpeedDial */
    value?: string | null;
    /** Id of extension to call */
    idExtension?: string | null;
    /** Position of line key. This is importante because maybe a user may want to skip some positions */
    lineKeyIndex?: number;
}

/** Group of line keys */
export interface LineKeyGroup {
    /** Id of document */
    readonly id?: string;
    /** Group of speed dial keys. Must have at least one */
    lineKeys?: LineKey[];
    /** Friendly name of line key group */
    friendlyName?: string;
    /** Description of line key group */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for LineKeyGroups */
export interface LineKeyGroupFilterRequest {
    /** LineKeys.LineKeyType equals */
    lineKeys_lineKeyType_eq?: string | null;
    /** LineKeys.LineKeyType contains */
    lineKeys_lineKeyType_con?: string | null;
    /** LineKeys.LineKeyType regex */
    lineKeys_lineKeyType_reg?: string | null;
    /** LineKeys.Label equals */
    lineKeys_label_eq?: string | null;
    /** LineKeys.Label contains */
    lineKeys_label_con?: string | null;
    /** LineKeys.Label regex */
    lineKeys_label_reg?: string | null;
    /** LineKeys.Value equals */
    lineKeys_value_eq?: string | null;
    /** LineKeys.Value contains */
    lineKeys_value_con?: string | null;
    /** LineKeys.Value regex */
    lineKeys_value_reg?: string | null;
    /** LineKeys.IdExtension equals */
    lineKeys_idExtension_eq?: string | null;
    /** LineKeys.IdExtension contains */
    lineKeys_idExtension_con?: string | null;
    /** LineKeys.IdExtension regex */
    lineKeys_idExtension_reg?: string | null;
    /** LineKeys.LineKeyIndex equals */
    lineKeys_lineKeyIndex_eq?: number | null;
    /** LineKeys.LineKeyIndex less than or equal to */
    lineKeys_lineKeyIndex_lte?: number | null;
    /** LineKeys.LineKeyIndex greater than or equal to */
    lineKeys_lineKeyIndex_gte?: number | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Group of line keys */
export interface LineKeyGroupUpdateRequest {
    /** Group of speed dial keys. Must have at least one */
    lineKeys?: LineKey[] | null;
    /** Friendly name of line key group */
    friendlyName?: string | null;
    /** Description of line key group */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Type of speed dial */
export enum LineKeyType {
    None = "None",
    Extension = "Extension",
    SpeedDial = "SpeedDial",
}

/** It is part of a phone. Lines are needed in order to make and receive phone calls. */
export interface LineUpdateRequest {
    friendlyName?: string | null;
    /** Caller id number that will be used to place outbound calls */
    callerIdNumber?: string | null;
    /** Record outbound calls to PSTN? */
    recordExternalCalls?: boolean | null;
    /** Record calls to other extensions? */
    recordInternalCalls?: boolean | null;
    /** Users will be charged extra for AI transcriptions. If this is true external calls to PSTN will be recorded. */
    useAiForExternalCalls?: boolean | null;
    /** Users will be charged extra for AI transcriptions. If this is true internal calls to extensions will be recorded. */
    useAiForOutgoingCallsToExtensions?: boolean | null;
    /** What input to pass to AI engine. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    language?: Language;
}

/** Mailing address */
export interface MailingAddress {
    /** Recipient name */
    recipientName?: string;
    /** Business Name */
    businessName?: string | null;
    /** Street address */
    streetAddress?: string;
    /** Unit number */
    apparmentOrSuiteNumber?: string | null;
    /** City */
    city?: string;
    /** State */
    state?: string;
    /** Zip code */
    zipCode?: string;
    country?: CountryIsoCode;
}

/** Multiple audios to be used as music on hold */
export interface MusicOnHoldGroup {
    /** Id of document */
    readonly id?: string;
    /** Audios to play meanwhile on hold */
    idsAudios?: string[];
    /** Name of music on hold group */
    friendlyName?: string;
    /** Description of music on hold group */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for MusicOnHoldGroups */
export interface MusicOnHoldGroupFilterRequest {
    /** IdsAudios equals */
    idsAudios_eq?: string | null;
    /** IdsAudios contains */
    idsAudios_con?: string | null;
    /** IdsAudios regex */
    idsAudios_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Multiple audios to be used as music on hold */
export interface MusicOnHoldGroupUpdateRequest {
    /** Audios to play meanwhile on hold */
    idsAudios?: string[] | null;
    /** Name of music on hold group */
    friendlyName?: string | null;
    /** Description of music on hold group */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

export interface NodeAPI {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeAnyDigits {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeAnyTime {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeAnyWeekDay {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeBookmark {
    /** Name of bookmark */
    name?: string;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeCall {
    /** Phone number to call */
    phoneNumber?: string;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeCallBackAPI {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeComment {
    /** A comment to describe what is happening in a call flow. */
    comment?: string;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeDigits {
    /** If is this digits. */
    isDigits?: string | null;
    /** If is greater than this digits */
    isGreaterThanDigits?: string | null;
    /** If is less than this digits */
    isLessThanDigits?: string | null;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeDynamicExtension {
    /** If extension is not found then call this extension */
    idExtensionDefault?: string | null;
    /** Prevent calling this extensions */
    idsExtensionsToExclude?: string[];
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeExtension {
    /** Extension to call */
    readonly idExtensionOrNumber?: string;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeGoTo {
    /** Bookmark to go to */
    bookmark?: string;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeHangup {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeIfDigits {
    flowNodeType?: FlowNodeType;
    readonly children?: FlowNode[];
}

export interface NodeIfLineOffline {
    flowNodeType?: FlowNodeType;
    readonly children?: FlowNode[];
}

export interface NodeIfTime {
    flowNodeType?: FlowNodeType;
    readonly children?: FlowNode[];
}

export interface NodeIfWeekDay {
    flowNodeType?: FlowNodeType;
    readonly children?: FlowNode[];
}

export interface NodeLineOffline {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeLineOnline {
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodePause {
    /** Number of seconds to pause */
    seconds?: number;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodePlay {
    /** Audio to play */
    idAudio?: string;
    /** Save and collect digits user enters */
    collectDigits?: boolean;
    /** Maximum number of digits to collect */
    maxNumberOfDigits?: number;
    /** Time to wait to collect digits after text is said */
    timeout?: number;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeSay {
    /** Type of voice. Example: US English - Joanna */
    voice?: string;
    /** Text to say */
    text?: string;
    /** Save and collect digits user enters */
    collectDigits?: boolean;
    /** Maximum number of digits to collect */
    maxNumberOfDigits?: number;
    /** Time to wait to collect digits after text is said */
    timeout?: number;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

export interface NodeTime {
    /** Start time in 24 hour format. Example 14:00 */
    startTime?: string;
    /** Start time in 24 hour format. Example 16:30 */
    endTime?: string;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

/** For example from Monday to Friday */
export interface NodeWeekDays {
    start?: DayOfWeek;
    end?: DayOfWeek;
    flowNodeType?: FlowNodeType;
    child?: FlowNode;
}

/** Previously called IpPhone. Represents a phone in UBLUX */
export interface Phone {
    /** Id of document */
    readonly id?: string;
    /** This specifies to what PBX it will be connected to */
    idCloudServicePbx?: string;
    /** Configuration phone will use */
    idPhoneConfiguration?: string | null;
    /** Username and password to login to web-app */
    idUser?: string | null;
    /** Descriptive name of phone */
    friendlyName?: string;
    phoneType?: PhoneType;
    /** Disable encryption in case device does not support it */
    disableEncryption?: boolean;
    /** Date when phone downloaded configuration from api.ublux.com in order to connect to Ublux */
    readonly dateAutoProvision?: Date | null;
    /** Mac address of phone in case it is a phisical phone that autoprovisions with Ublux. */
    readonly macAddress?: string | null;
    /** User Agent */
    readonly userAgent?: string | null;
    /** Device pin of 5 random digits used to connect phone in case extension is used by multiple phones */
    readonly pin?: string;
    /** TimeZone of this phone */
    timeZone?: string;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
    /** Phone lines. Should never be null */
    lines?: Line[];
}

/** Configuration of a phone */
export interface PhoneConfiguration {
    /** Id of document */
    readonly id?: string;
    /** Line keys to use */
    idLineKeyGroup?: string | null;
    /** Phone configuration name */
    frienlyName?: string;
    /** Phone configuration description */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for PhoneConfigurations */
export interface PhoneConfigurationFilterRequest {
    /** IdLineKeyGroup equals */
    idLineKeyGroup_eq?: string | null;
    /** IdLineKeyGroup contains */
    idLineKeyGroup_con?: string | null;
    /** IdLineKeyGroup regex */
    idLineKeyGroup_reg?: string | null;
    /** FrienlyName equals */
    frienlyName_eq?: string | null;
    /** FrienlyName contains */
    frienlyName_con?: string | null;
    /** FrienlyName regex */
    frienlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Configuration of a phone */
export interface PhoneConfigurationUpdateRequest {
    /** Line keys to use */
    idLineKeyGroup?: string | null;
    /** Phone configuration name */
    frienlyName?: string | null;
    /** Phone configuration description */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Enables searching for Phones */
export interface PhoneFilterRequest {
    /** IdCloudServicePbx equals */
    idCloudServicePbx_eq?: string | null;
    /** IdCloudServicePbx contains */
    idCloudServicePbx_con?: string | null;
    /** IdCloudServicePbx regex */
    idCloudServicePbx_reg?: string | null;
    /** IdPhoneConfiguration equals */
    idPhoneConfiguration_eq?: string | null;
    /** IdPhoneConfiguration contains */
    idPhoneConfiguration_con?: string | null;
    /** IdPhoneConfiguration regex */
    idPhoneConfiguration_reg?: string | null;
    /** IdUser equals */
    idUser_eq?: string | null;
    /** IdUser contains */
    idUser_con?: string | null;
    /** IdUser regex */
    idUser_reg?: string | null;
    /** Lines.FriendlyName equals */
    lines_friendlyName_eq?: string | null;
    /** Lines.FriendlyName contains */
    lines_friendlyName_con?: string | null;
    /** Lines.FriendlyName regex */
    lines_friendlyName_reg?: string | null;
    /** Lines.LineConnectionStatus.IpWAN equals */
    lines_lineConnectionStatus_ipWAN_eq?: string | null;
    /** Lines.LineConnectionStatus.IpWAN contains */
    lines_lineConnectionStatus_ipWAN_con?: string | null;
    /** Lines.LineConnectionStatus.IpWAN regex */
    lines_lineConnectionStatus_ipWAN_reg?: string | null;
    /** Lines.LineConnectionStatus.PortWAN equals */
    lines_lineConnectionStatus_portWAN_eq?: number | null;
    /** Lines.LineConnectionStatus.PortWAN less than or equal to */
    lines_lineConnectionStatus_portWAN_lte?: number | null;
    /** Lines.LineConnectionStatus.PortWAN greater than or equal to */
    lines_lineConnectionStatus_portWAN_gte?: number | null;
    /** Lines.LineConnectionStatus.IpLAN equals */
    lines_lineConnectionStatus_ipLAN_eq?: string | null;
    /** Lines.LineConnectionStatus.IpLAN contains */
    lines_lineConnectionStatus_ipLAN_con?: string | null;
    /** Lines.LineConnectionStatus.IpLAN regex */
    lines_lineConnectionStatus_ipLAN_reg?: string | null;
    /** Lines.LineConnectionStatus.PortLAN equals */
    lines_lineConnectionStatus_portLAN_eq?: number | null;
    /** Lines.LineConnectionStatus.PortLAN less than or equal to */
    lines_lineConnectionStatus_portLAN_lte?: number | null;
    /** Lines.LineConnectionStatus.PortLAN greater than or equal to */
    lines_lineConnectionStatus_portLAN_gte?: number | null;
    /** Lines.LineConnectionStatus.UserAgent equals */
    lines_lineConnectionStatus_userAgent_eq?: string | null;
    /** Lines.LineConnectionStatus.UserAgent contains */
    lines_lineConnectionStatus_userAgent_con?: string | null;
    /** Lines.LineConnectionStatus.UserAgent regex */
    lines_lineConnectionStatus_userAgent_reg?: string | null;
    /** Lines.LineConnectionStatus.IsConnected equals */
    lines_lineConnectionStatus_isConnected_eq?: boolean | null;
    /** Lines.LineConnectionStatus.DisconnectedReason equals */
    lines_lineConnectionStatus_disconnectedReason_eq?: string | null;
    /** Lines.LineConnectionStatus.DisconnectedReason contains */
    lines_lineConnectionStatus_disconnectedReason_con?: string | null;
    /** Lines.LineConnectionStatus.DisconnectedReason regex */
    lines_lineConnectionStatus_disconnectedReason_reg?: string | null;
    /** Lines.LineConnectionStatus.DateConnected equals */
    lines_lineConnectionStatus_dateConnected_eq?: Date | null;
    /** Lines.LineConnectionStatus.DateConnected less than or equal to */
    lines_lineConnectionStatus_dateConnected_lte?: Date | null;
    /** Lines.LineConnectionStatus.DateConnected greater than or equal to */
    lines_lineConnectionStatus_dateConnected_gte?: Date | null;
    /** Lines.LineConnectionStatus.DateDisconnected equals */
    lines_lineConnectionStatus_dateDisconnected_eq?: Date | null;
    /** Lines.LineConnectionStatus.DateDisconnected less than or equal to */
    lines_lineConnectionStatus_dateDisconnected_lte?: Date | null;
    /** Lines.LineConnectionStatus.DateDisconnected greater than or equal to */
    lines_lineConnectionStatus_dateDisconnected_gte?: Date | null;
    /** Lines.CallerIdNumber equals */
    lines_callerIdNumber_eq?: string | null;
    /** Lines.CallerIdNumber contains */
    lines_callerIdNumber_con?: string | null;
    /** Lines.CallerIdNumber regex */
    lines_callerIdNumber_reg?: string | null;
    /** Lines.RecordExternalCalls equals */
    lines_recordExternalCalls_eq?: boolean | null;
    /** Lines.RecordInternalCalls equals */
    lines_recordInternalCalls_eq?: boolean | null;
    /** Lines.UseAiForExternalCalls equals */
    lines_useAiForExternalCalls_eq?: boolean | null;
    /** Lines.UseAiForOutgoingCallsToExtensions equals */
    lines_useAiForOutgoingCallsToExtensions_eq?: boolean | null;
    /** Lines.IdAiCallAnalysisInput equals */
    lines_idAiCallAnalysisInput_eq?: string | null;
    /** Lines.IdAiCallAnalysisInput contains */
    lines_idAiCallAnalysisInput_con?: string | null;
    /** Lines.IdAiCallAnalysisInput regex */
    lines_idAiCallAnalysisInput_reg?: string | null;
    /** Lines.Language equals */
    lines_language_eq?: string | null;
    /** Lines.Language contains */
    lines_language_con?: string | null;
    /** Lines.Language regex */
    lines_language_reg?: string | null;
    /** Lines.Id equals */
    lines_id_eq?: string | null;
    /** Lines.Id contains */
    lines_id_con?: string | null;
    /** Lines.Id regex */
    lines_id_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** PhoneType equals */
    phoneType_eq?: string | null;
    /** PhoneType contains */
    phoneType_con?: string | null;
    /** PhoneType regex */
    phoneType_reg?: string | null;
    /** DisableEncryption equals */
    disableEncryption_eq?: boolean | null;
    /** DateAutoProvision equals */
    dateAutoProvision_eq?: Date | null;
    /** DateAutoProvision less than or equal to */
    dateAutoProvision_lte?: Date | null;
    /** DateAutoProvision greater than or equal to */
    dateAutoProvision_gte?: Date | null;
    /** MacAddress equals */
    macAddress_eq?: string | null;
    /** MacAddress contains */
    macAddress_con?: string | null;
    /** MacAddress regex */
    macAddress_reg?: string | null;
    /** UserAgent equals */
    userAgent_eq?: string | null;
    /** UserAgent contains */
    userAgent_con?: string | null;
    /** UserAgent regex */
    userAgent_reg?: string | null;
    /** Pin equals */
    pin_eq?: string | null;
    /** Pin contains */
    pin_con?: string | null;
    /** Pin regex */
    pin_reg?: string | null;
    /** TimeZone equals */
    timeZone_eq?: string | null;
    /** TimeZone contains */
    timeZone_con?: string | null;
    /** TimeZone regex */
    timeZone_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Physical phone */
export enum PhoneType {
    Physical = "Physical",
    Web = "Web",
}

/** Previously called IpPhone. Represents a phone in UBLUX */
export interface PhoneUpdateRequest {
    /** This specifies to what PBX it will be connected to */
    idCloudServicePbx?: string | null;
    /** Configuration phone will use */
    idPhoneConfiguration?: string | null;
    /** Username and password to login to web-app */
    idUser?: string | null;
    /** Phone lines. Should never be null */
    lines?: Line[] | null;
    /** Descriptive name of phone */
    friendlyName?: string | null;
    phoneType?: PhoneType;
    /** Disable encryption in case device does not support it */
    disableEncryption?: boolean | null;
    /** TimeZone of this phone */
    timeZone?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Peer to call on power dialer group */
export interface PowerDialerContact {
    /** Phone number to call */
    phoneNumber?: string;
    countryIsoCode?: CountryIsoCode;
    /** Id of contact */
    readonly idContact?: string | null;
    powerDialerStatus?: PowerDialerStatus;
    /** Error message */
    errorMessage?: string | null;
    /** If powerdialer fails it attempts to call again. If it reaches 3 attempts and fails it will stop */
    numberOfAttempts?: number;
    /** Name of the contact in order to know who are we calling */
    contactName?: string | null;
}

/** Group used to call multiple parties */
export interface PowerDialerGroup {
    /** Id of document */
    readonly id?: string;
    /** From what phone number we will make call. */
    readonly idVoipNumberPhone?: string | null;
    /** Override caller id? */
    readonly idCallerIdMask?: string | null;
    /** Agents that will be using power dialer */
    idLinesAgents?: string[];
    /** Subdocument */
    readonly powerDialerContacts?: PowerDialerContact[];
    /** Friendly name of power dialer group */
    friendlyName?: string;
    /** Description of power dialer group */
    description?: string | null;
    powerDialerGroupStatus?: PowerDialerGroupStatus;
    /** If there is an error in general with the group and NOT with a power dialer item contact. */
    readonly errorMessage?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for PowerDialerGroups */
export interface PowerDialerGroupFilterRequest {
    /** IdVoipNumberPhone equals */
    idVoipNumberPhone_eq?: string | null;
    /** IdVoipNumberPhone contains */
    idVoipNumberPhone_con?: string | null;
    /** IdVoipNumberPhone regex */
    idVoipNumberPhone_reg?: string | null;
    /** IdCallerIdMask equals */
    idCallerIdMask_eq?: string | null;
    /** IdCallerIdMask contains */
    idCallerIdMask_con?: string | null;
    /** IdCallerIdMask regex */
    idCallerIdMask_reg?: string | null;
    /** IdLinesAgents equals */
    idLinesAgents_eq?: string | null;
    /** IdLinesAgents contains */
    idLinesAgents_con?: string | null;
    /** IdLinesAgents regex */
    idLinesAgents_reg?: string | null;
    /** PowerDialerContacts.PhoneNumber equals */
    powerDialerContacts_phoneNumber_eq?: string | null;
    /** PowerDialerContacts.PhoneNumber contains */
    powerDialerContacts_phoneNumber_con?: string | null;
    /** PowerDialerContacts.PhoneNumber regex */
    powerDialerContacts_phoneNumber_reg?: string | null;
    /** PowerDialerContacts.CountryIsoCode equals */
    powerDialerContacts_countryIsoCode_eq?: string | null;
    /** PowerDialerContacts.CountryIsoCode contains */
    powerDialerContacts_countryIsoCode_con?: string | null;
    /** PowerDialerContacts.CountryIsoCode regex */
    powerDialerContacts_countryIsoCode_reg?: string | null;
    /** PowerDialerContacts.IdContact equals */
    powerDialerContacts_idContact_eq?: string | null;
    /** PowerDialerContacts.IdContact contains */
    powerDialerContacts_idContact_con?: string | null;
    /** PowerDialerContacts.IdContact regex */
    powerDialerContacts_idContact_reg?: string | null;
    /** PowerDialerContacts.PowerDialerStatus equals */
    powerDialerContacts_powerDialerStatus_eq?: string | null;
    /** PowerDialerContacts.PowerDialerStatus contains */
    powerDialerContacts_powerDialerStatus_con?: string | null;
    /** PowerDialerContacts.PowerDialerStatus regex */
    powerDialerContacts_powerDialerStatus_reg?: string | null;
    /** PowerDialerContacts.ErrorMessage equals */
    powerDialerContacts_errorMessage_eq?: string | null;
    /** PowerDialerContacts.ErrorMessage contains */
    powerDialerContacts_errorMessage_con?: string | null;
    /** PowerDialerContacts.ErrorMessage regex */
    powerDialerContacts_errorMessage_reg?: string | null;
    /** PowerDialerContacts.NumberOfAttempts equals */
    powerDialerContacts_numberOfAttempts_eq?: number | null;
    /** PowerDialerContacts.NumberOfAttempts less than or equal to */
    powerDialerContacts_numberOfAttempts_lte?: number | null;
    /** PowerDialerContacts.NumberOfAttempts greater than or equal to */
    powerDialerContacts_numberOfAttempts_gte?: number | null;
    /** PowerDialerContacts.ContactName equals */
    powerDialerContacts_contactName_eq?: string | null;
    /** PowerDialerContacts.ContactName contains */
    powerDialerContacts_contactName_con?: string | null;
    /** PowerDialerContacts.ContactName regex */
    powerDialerContacts_contactName_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** PowerDialerGroupStatus equals */
    powerDialerGroupStatus_eq?: string | null;
    /** PowerDialerGroupStatus contains */
    powerDialerGroupStatus_con?: string | null;
    /** PowerDialerGroupStatus regex */
    powerDialerGroupStatus_reg?: string | null;
    /** ErrorMessage equals */
    errorMessage_eq?: string | null;
    /** ErrorMessage contains */
    errorMessage_con?: string | null;
    /** ErrorMessage regex */
    errorMessage_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Status of power dialer group */
export enum PowerDialerGroupStatus {
    None = "None",
    Pending = "Pending",
    Started = "Started",
    Paused = "Paused",
    Canceled = "Canceled",
    Failed = "Failed",
    Completed = "Completed",
}

/** Group used to call multiple parties */
export interface PowerDialerGroupUpdateRequest {
    /** Agents that will be using power dialer */
    idLinesAgents?: string[] | null;
    /** Friendly name of power dialer group */
    friendlyName?: string | null;
    /** Description of power dialer group */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Status of power dialer */
export enum PowerDialerStatus {
    None = "None",
    Pending = "Pending",
    AssignedToAgent = "AssignedToAgent",
    Started = "Started",
    Failed = "Failed",
    Completed = "Completed",
}

export interface ProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
}

/** Status of something that is being processed. For example the transcription of a call using whisper or analysis of call using chat GPT. */
export enum ProcessStatus {
    None = "None",
    Pending = "Pending",
    Queued = "Queued",
    Processing = "Processing",
    Complete = "Complete",
}

/** Ring strategy of a queue */
export enum QueueRingStrategy {
    None = "None",
    RingAll = "RingAll",
    LeastResent = "LeastResent",
    FewestCalls = "FewestCalls",
    Random = "Random",
    RoundRobin = "RoundRobin",
    Linear = "Linear",
}

/** Recording of a phone call */
export interface Recording {
    /** Description of error message if there is one */
    readonly errorMessage?: string | null;
    recordingClientMp3?: StoredFile;
    recordingAgentMp3?: StoredFile;
    recordingMp3?: StoredFile;
    /** Duration of recording */
    readonly recordingDurationInSeconds?: number;
    /** Id of entity */
    readonly id?: string;
}

/** Rule to execute when receiving fax */
export interface RuleFax {
    /** Email address where to send fax */
    idEmail?: string;
}

/** Rule that determines what action to execute when a phone call is received. */
export interface RulePhone {
    /** Id of Call Flow (IVR) to execute */
    idCallFlowLogic?: string | null;
    /** Id of extension to call */
    idExtension?: string | null;
    /** Day of week when to execute */
    daysOfWeek?: DayOfWeek[];
}

/** Rule to execute when receiving SMS */
export interface RuleSms {
    /** Email address where to send SMS */
    idEmail?: string;
}

/** SMS message */
export interface SMS {
    /** Id of document */
    readonly id?: string;
    /** VOIP number that sent/received SMS message */
    readonly idVoipNumber?: string;
    /** Contact */
    readonly idContact?: string | null;
    /** True if SMS was received false otherwise */
    readonly isIncoming?: boolean;
    /** SMS message */
    readonly body?: string;
    /** If a SMS body is to large, it will be sent in multiple chunks/segments */
    readonly numSegments?: number;
    /** Number that sent SMS */
    readonly from?: string;
    /** Number to whom SMS was sent to */
    readonly to?: string;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for SMSs */
export interface SMSFilterRequest {
    /** IdVoipNumber equals */
    idVoipNumber_eq?: string | null;
    /** IdVoipNumber contains */
    idVoipNumber_con?: string | null;
    /** IdVoipNumber regex */
    idVoipNumber_reg?: string | null;
    /** IdContact equals */
    idContact_eq?: string | null;
    /** IdContact contains */
    idContact_con?: string | null;
    /** IdContact regex */
    idContact_reg?: string | null;
    /** IsIncoming equals */
    isIncoming_eq?: boolean | null;
    /** Body equals */
    body_eq?: string | null;
    /** Body contains */
    body_con?: string | null;
    /** Body regex */
    body_reg?: string | null;
    /** NumSegments equals */
    numSegments_eq?: number | null;
    /** NumSegments less than or equal to */
    numSegments_lte?: number | null;
    /** NumSegments greater than or equal to */
    numSegments_gte?: number | null;
    /** From equals */
    from_eq?: string | null;
    /** From contains */
    from_con?: string | null;
    /** From regex */
    from_reg?: string | null;
    /** To equals */
    to_eq?: string | null;
    /** To contains */
    to_con?: string | null;
    /** To regex */
    to_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** SMS message */
export interface SMSUpdateRequest {
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Send email notification if call takes to long to be answered. This is used for extension queue */
export interface SendEmailNotificationIfItTakesToLongToBeAnswered {
    /** Send email notification if call takes more than this amount of time to be answered */
    timeInSeconds?: number;
    /** Email addresses where to send notifications in case call is not answered. */
    idsEmails?: string[];
}

/** Send email notification if call or extension is not answered */
export interface SendEmailNotificationIfNotAnswered {
    /** Email addresses where to send notification in case call is not answered. */
    idsEmails?: string[];
    /** If a caller calls and hung up right away then maybe we don't want to send a notification. */
    preventSendingNotificationIfLastLessThanNSeconds?: number;
}

/** Simple notification service message */
export interface SnsMessage {
    /** Id of message */
    id?: string;
    /** Date when message was created in UTC */
    dateCreated?: Date;
    snsTopic?: SnsTopic;
    /** Message data */
    message?: string | null;
    /** Id of account. Use account 27 for internal events */
    readonly idAccount?: string;
    /** If a phone was modified then the id of the phone */
    idCollection?: string | null;
    collection?: Collections;
    /** Data of message. This may be json data */
    data?: any | null;
    /** If there is data then what type of data is it */
    dataType?: string | null;
    /** Created by instance id */
    origin?: string;
    /** Any helpful data */
    tag?: any | null;
    /** If there is a Tag then its type */
    tagType?: string | null;
}

/** Simple notification service topic. Example call_completed. */
export enum SnsTopic {
    Collection_Created = "Collection_Created",
    Collection_Updated = "Collection_Updated",
    Collection_Deleted = "Collection_Deleted",
    Transcription_Complete = "Transcription_Complete",
    AiAnalysis_Complete = "AiAnalysis_Complete",
    Call_Started = "Call_Started",
    Call_Terminated = "Call_Terminated",
    Line_Disconnected = "Line_Disconnected",
    Line_Connected = "Line_Connected",
    Extension_Unanswered = "Extension_Unanswered",
    Extension_Answered = "Extension_Answered",
    Extension_TookToLongToBeAnswered = "Extension_TookToLongToBeAnswered",
    Call_PlacedOnHoldForTooLong = "Call_PlacedOnHoldForTooLong",
    Fax_Received = "Fax_Received",
    Fax_Sent = "Fax_Sent",
    Fax_ReceivedFailed = "Fax_ReceivedFailed",
    Fax_SentFailed = "Fax_SentFailed",
    Fax_ReceivingProgress = "Fax_ReceivingProgress",
    Fax_SendingProgress = "Fax_SendingProgress",
    CallFlowLogic_Progress = "CallFlowLogic_Progress",
    BLF = "BLF",
}

/** Represents a stored file in ublux such as a recording or audio. */
export interface StoredFile {
    /** Server that stored this file so that other servers can download it. Example W for work. Thus it can be downloaded from w.ublux.com */
    readonly instanceId?: string;
    /** New because we removed table account data
How big the file is */
    readonly fileSizeInBytes?: number;
    /** Md5 hash of file */
    readonly md5Hash?: string;
    /** Link where it can be downloaded. Example: https://api.ublux.com/StoredFile/Ac.1/audios/SF.xxxxxxxx.mp3 */
    readonly url?: string;
    /** Id of entity */
    readonly id?: string;
}

/** Category */
export interface Tag {
    /** Id of document */
    readonly id?: string;
    /** Name of tag */
    friendlyName?: string;
    tagColor?: TagColor;
    /** Description of tag */
    description?: string | null;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Color of a tag */
export enum TagColor {
    None = "None",
    Black = "Black",
    Navy = "Navy",
    DarkBlue = "DarkBlue",
    MediumBlue = "MediumBlue",
    Blue = "Blue",
    DarkGreen = "DarkGreen",
    Green = "Green",
    Teal = "Teal",
    DarkCyan = "DarkCyan",
    DeepSkyBlue = "DeepSkyBlue",
    DarkTurquoise = "DarkTurquoise",
    MediumSpringGreen = "MediumSpringGreen",
    Lime = "Lime",
    SpringGreen = "SpringGreen",
    Aqua = "Aqua",
    Cyan = "Cyan",
    MidnightBlue = "MidnightBlue",
    DodgerBlue = "DodgerBlue",
    LightSeaGreen = "LightSeaGreen",
    ForestGreen = "ForestGreen",
    SeaGreen = "SeaGreen",
    DarkSlateGray = "DarkSlateGray",
    DarkSlateGrey = "DarkSlateGrey",
    LimeGreen = "LimeGreen",
    MediumSeaGreen = "MediumSeaGreen",
    Turquoise = "Turquoise",
    RoyalBlue = "RoyalBlue",
    SteelBlue = "SteelBlue",
    DarkSlateBlue = "DarkSlateBlue",
    MediumTurquoise = "MediumTurquoise",
    Indigo = "Indigo",
    DarkOliveGreen = "DarkOliveGreen",
    CadetBlue = "CadetBlue",
    CornflowerBlue = "CornflowerBlue",
    RebeccaPurple = "RebeccaPurple",
    MediumAquaMarine = "MediumAquaMarine",
    DimGray = "DimGray",
    DimGrey = "DimGrey",
    SlateBlue = "SlateBlue",
    OliveDrab = "OliveDrab",
    SlateGray = "SlateGray",
    SlateGrey = "SlateGrey",
    LightSlateGray = "LightSlateGray",
    LightSlateGrey = "LightSlateGrey",
    MediumSlateBlue = "MediumSlateBlue",
    LawnGreen = "LawnGreen",
    Chartreuse = "Chartreuse",
    Aquamarine = "Aquamarine",
    Maroon = "Maroon",
    Purple = "Purple",
    Olive = "Olive",
    Gray = "Gray",
    Grey = "Grey",
    SkyBlue = "SkyBlue",
    LightSkyBlue = "LightSkyBlue",
    BlueViolet = "BlueViolet",
    DarkRed = "DarkRed",
    DarkMagenta = "DarkMagenta",
    SaddleBrown = "SaddleBrown",
    DarkSeaGreen = "DarkSeaGreen",
    LightGreen = "LightGreen",
    MediumPurple = "MediumPurple",
    DarkViolet = "DarkViolet",
    PaleGreen = "PaleGreen",
    DarkOrchid = "DarkOrchid",
    YellowGreen = "YellowGreen",
    Sienna = "Sienna",
    Brown = "Brown",
    DarkGray = "DarkGray",
    DarkGrey = "DarkGrey",
    LightBlue = "LightBlue",
    GreenYellow = "GreenYellow",
    PaleTurquoise = "PaleTurquoise",
    LightSteelBlue = "LightSteelBlue",
    PowderBlue = "PowderBlue",
    FireBrick = "FireBrick",
    DarkGoldenRod = "DarkGoldenRod",
    MediumOrchid = "MediumOrchid",
    RosyBrown = "RosyBrown",
    DarkKhaki = "DarkKhaki",
    Silver = "Silver",
    MediumVioletRed = "MediumVioletRed",
    IndianRed = "IndianRed",
    Peru = "Peru",
    Chocolate = "Chocolate",
    Tan = "Tan",
    LightGray = "LightGray",
    LightGrey = "LightGrey",
    Thistle = "Thistle",
    Orchid = "Orchid",
    GoldenRod = "GoldenRod",
    PaleVioletRed = "PaleVioletRed",
    Crimson = "Crimson",
    Gainsboro = "Gainsboro",
    Plum = "Plum",
    BurlyWood = "BurlyWood",
    LightCyan = "LightCyan",
    Lavender = "Lavender",
    DarkSalmon = "DarkSalmon",
    Violet = "Violet",
    PaleGoldenRod = "PaleGoldenRod",
    LightCoral = "LightCoral",
    Khaki = "Khaki",
    AliceBlue = "AliceBlue",
    HoneyDew = "HoneyDew",
    Azure = "Azure",
    SandyBrown = "SandyBrown",
    Wheat = "Wheat",
    Beige = "Beige",
    WhiteSmoke = "WhiteSmoke",
    MintCream = "MintCream",
    GhostWhite = "GhostWhite",
    Salmon = "Salmon",
    AntiqueWhite = "AntiqueWhite",
    Linen = "Linen",
    LightGoldenRodYellow = "LightGoldenRodYellow",
    OldLace = "OldLace",
    Red = "Red",
    Fuchsia = "Fuchsia",
    Magenta = "Magenta",
    DeepPink = "DeepPink",
    OrangeRed = "OrangeRed",
    Tomato = "Tomato",
    HotPink = "HotPink",
    Coral = "Coral",
    DarkOrange = "DarkOrange",
    LightSalmon = "LightSalmon",
    Orange = "Orange",
    LightPink = "LightPink",
    Pink = "Pink",
    Gold = "Gold",
    PeachPuff = "PeachPuff",
    NavajoWhite = "NavajoWhite",
    Moccasin = "Moccasin",
    Bisque = "Bisque",
    MistyRose = "MistyRose",
    BlanchedAlmond = "BlanchedAlmond",
    PapayaWhip = "PapayaWhip",
    LavenderBlush = "LavenderBlush",
    SeaShell = "SeaShell",
    Cornsilk = "Cornsilk",
    LemonChiffon = "LemonChiffon",
    FloralWhite = "FloralWhite",
    Snow = "Snow",
    Yellow = "Yellow",
    LightYellow = "LightYellow",
    Ivory = "Ivory",
    White = "White",
}

/** Enables searching for Tags */
export interface TagFilterRequest {
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** TagColor equals */
    tagColor_eq?: string | null;
    /** TagColor contains */
    tagColor_con?: string | null;
    /** TagColor regex */
    tagColor_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Category */
export interface TagUpdateRequest {
    /** Name of tag */
    friendlyName?: string | null;
    tagColor?: TagColor;
    /** Description of tag */
    description?: string | null;
}

/** Date when call was placed on hold */
export interface TimeWhenCallPlacedOnHold {
    /** Seconds elapsed since the call started when call was placed on hold */
    readonly secondsElapsedWhenPlacedOnHold?: number;
    /** Seconds elapsed since the call started when call was removed from hold */
    readonly secondsElapsedWhenRemovedFromHold?: number | null;
}

/** Trunk used to receive phone calls. Multiple VoipNumbers can point to the same trunk origination. */
export interface TrunkOrigination {
    /** Id of document */
    readonly id?: string;
    trunkOriginationType?: TrunkOriginationType;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Types of trunk originations */
export enum TrunkOriginationType {
    None = "None",
    Forward = "Forward",
    Register = "Register",
}

/** Trunk used to receive phone calls */
export interface TrunkTermination {
    /** Id of document */
    readonly id?: string;
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Group of trunk terminations ordered by priority */
export interface TrunkTerminationGroup {
    /** Id of document */
    readonly id?: string;
    /** Note: points to a shared_trunktermination and not a trunk termination
Example. ID of a twilio trunk to call US, then a trunk from victor to call Spain, then trunk */
    readonly trunkTerminationRulesOrderedByPriority?: TrunkTerminationRule[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Trunk termination allowed to call */
export interface TrunkTerminationRule {
    /** Trunk termination to use */
    readonly idTrunkTermination?: string;
    /** Countries that can be called */
    readonly countriesThatCanCall?: CountryIsoCode[];
}

/** A ublux user has this roles. They are sorted in order of priority */
export enum UbluxRole {
    None = "none",
    Audios = "audios",
    Audios_readonly = "audios_readonly",
    Audios_update = "audios_update",
    Audios_delete = "audios_delete",
    Audios_create = "audios_create",
    Blacklistphonenumbers = "blacklistphonenumbers",
    Blacklistphonenumbers_readonly = "blacklistphonenumbers_readonly",
    Blacklistphonenumbers_update = "blacklistphonenumbers_update",
    Blacklistphonenumbers_delete = "blacklistphonenumbers_delete",
    Blacklistphonenumbers_create = "blacklistphonenumbers_create",
    Calls = "calls",
    Calls_readonly = "calls_readonly",
    Calls_update = "calls_update",
    Calls_delete = "calls_delete",
    Calls_create = "calls_create",
    Calleridmasks = "calleridmasks",
    Calleridmasks_readonly = "calleridmasks_readonly",
    Calleridmasks_update = "calleridmasks_update",
    Calleridmasks_delete = "calleridmasks_delete",
    Calleridmasks_create = "calleridmasks_create",
    Callflowlogics = "callflowlogics",
    Callflowlogics_readonly = "callflowlogics_readonly",
    Callflowlogics_update = "callflowlogics_update",
    Callflowlogics_delete = "callflowlogics_delete",
    Callflowlogics_create = "callflowlogics_create",
    Callincomings = "callincomings",
    Callincomings_readonly = "callincomings_readonly",
    Callincomings_update = "callincomings_update",
    Callincomings_delete = "callincomings_delete",
    Callincomings_create = "callincomings_create",
    Callincomingtocallflowlogics = "callincomingtocallflowlogics",
    Callincomingtocallflowlogics_readonly = "callincomingtocallflowlogics_readonly",
    Callincomingtocallflowlogics_update = "callincomingtocallflowlogics_update",
    Callincomingtocallflowlogics_delete = "callincomingtocallflowlogics_delete",
    Callincomingtocallflowlogics_create = "callincomingtocallflowlogics_create",
    Callincomingtoextensions = "callincomingtoextensions",
    Callincomingtoextensions_readonly = "callincomingtoextensions_readonly",
    Callincomingtoextensions_update = "callincomingtoextensions_update",
    Callincomingtoextensions_delete = "callincomingtoextensions_delete",
    Callincomingtoextensions_create = "callincomingtoextensions_create",
    Calloutgoings = "calloutgoings",
    Calloutgoings_readonly = "calloutgoings_readonly",
    Calloutgoings_update = "calloutgoings_update",
    Calloutgoings_delete = "calloutgoings_delete",
    Calloutgoings_create = "calloutgoings_create",
    Calloutgoingtoextensions = "calloutgoingtoextensions",
    Calloutgoingtoextensions_readonly = "calloutgoingtoextensions_readonly",
    Calloutgoingtoextensions_update = "calloutgoingtoextensions_update",
    Calloutgoingtoextensions_delete = "calloutgoingtoextensions_delete",
    Calloutgoingtoextensions_create = "calloutgoingtoextensions_create",
    Calloutgoingtopstns = "calloutgoingtopstns",
    Calloutgoingtopstns_readonly = "calloutgoingtopstns_readonly",
    Calloutgoingtopstns_update = "calloutgoingtopstns_update",
    Calloutgoingtopstns_delete = "calloutgoingtopstns_delete",
    Calloutgoingtopstns_create = "calloutgoingtopstns_create",
    Contacts = "contacts",
    Contacts_readonly = "contacts_readonly",
    Contacts_update = "contacts_update",
    Contacts_delete = "contacts_delete",
    Contacts_create = "contacts_create",
    Customerinfos = "customerinfos",
    Customerinfos_readonly = "customerinfos_readonly",
    Customerinfos_update = "customerinfos_update",
    Customerinfos_delete = "customerinfos_delete",
    Customerinfos_create = "customerinfos_create",
    Extensions = "extensions",
    Extensions_readonly = "extensions_readonly",
    Extensions_update = "extensions_update",
    Extensions_delete = "extensions_delete",
    Extensions_create = "extensions_create",
    Extensioncallflowlogics = "extensioncallflowlogics",
    Extensioncallflowlogics_readonly = "extensioncallflowlogics_readonly",
    Extensioncallflowlogics_update = "extensioncallflowlogics_update",
    Extensioncallflowlogics_delete = "extensioncallflowlogics_delete",
    Extensioncallflowlogics_create = "extensioncallflowlogics_create",
    Extensionconferences = "extensionconferences",
    Extensionconferences_readonly = "extensionconferences_readonly",
    Extensionconferences_update = "extensionconferences_update",
    Extensionconferences_delete = "extensionconferences_delete",
    Extensionconferences_create = "extensionconferences_create",
    Extensiondials = "extensiondials",
    Extensiondials_readonly = "extensiondials_readonly",
    Extensiondials_update = "extensiondials_update",
    Extensiondials_delete = "extensiondials_delete",
    Extensiondials_create = "extensiondials_create",
    Extensionqueues = "extensionqueues",
    Extensionqueues_readonly = "extensionqueues_readonly",
    Extensionqueues_update = "extensionqueues_update",
    Extensionqueues_delete = "extensionqueues_delete",
    Extensionqueues_create = "extensionqueues_create",
    Extensionvoicemails = "extensionvoicemails",
    Extensionvoicemails_readonly = "extensionvoicemails_readonly",
    Extensionvoicemails_update = "extensionvoicemails_update",
    Extensionvoicemails_delete = "extensionvoicemails_delete",
    Extensionvoicemails_create = "extensionvoicemails_create",
    Emails = "emails",
    Emails_readonly = "emails_readonly",
    Emails_update = "emails_update",
    Emails_delete = "emails_delete",
    Emails_create = "emails_create",
    Faxincomings = "faxincomings",
    Faxincomings_readonly = "faxincomings_readonly",
    Faxincomings_update = "faxincomings_update",
    Faxincomings_delete = "faxincomings_delete",
    Faxincomings_create = "faxincomings_create",
    Faxoutgoinggroups = "faxoutgoinggroups",
    Faxoutgoinggroups_readonly = "faxoutgoinggroups_readonly",
    Faxoutgoinggroups_update = "faxoutgoinggroups_update",
    Faxoutgoinggroups_delete = "faxoutgoinggroups_delete",
    Faxoutgoinggroups_create = "faxoutgoinggroups_create",
    Users = "users",
    Users_readonly = "users_readonly",
    Users_update = "users_update",
    Users_delete = "users_delete",
    Users_create = "users_create",
    Linekeygroups = "linekeygroups",
    Linekeygroups_readonly = "linekeygroups_readonly",
    Linekeygroups_update = "linekeygroups_update",
    Linekeygroups_delete = "linekeygroups_delete",
    Linekeygroups_create = "linekeygroups_create",
    Musiconholdgroups = "musiconholdgroups",
    Musiconholdgroups_readonly = "musiconholdgroups_readonly",
    Musiconholdgroups_update = "musiconholdgroups_update",
    Musiconholdgroups_delete = "musiconholdgroups_delete",
    Musiconholdgroups_create = "musiconholdgroups_create",
    Phones = "phones",
    Phones_readonly = "phones_readonly",
    Phones_update = "phones_update",
    Phones_delete = "phones_delete",
    Phones_create = "phones_create",
    Phoneconfigurations = "phoneconfigurations",
    Phoneconfigurations_readonly = "phoneconfigurations_readonly",
    Phoneconfigurations_update = "phoneconfigurations_update",
    Phoneconfigurations_delete = "phoneconfigurations_delete",
    Phoneconfigurations_create = "phoneconfigurations_create",
    Powerdialergroups = "powerdialergroups",
    Powerdialergroups_readonly = "powerdialergroups_readonly",
    Powerdialergroups_update = "powerdialergroups_update",
    Powerdialergroups_delete = "powerdialergroups_delete",
    Powerdialergroups_create = "powerdialergroups_create",
    Sms = "sms",
    Sms_readonly = "sms_readonly",
    Sms_update = "sms_update",
    Sms_delete = "sms_delete",
    Sms_create = "sms_create",
    Voicemails = "voicemails",
    Voicemails_readonly = "voicemails_readonly",
    Voicemails_update = "voicemails_update",
    Voicemails_delete = "voicemails_delete",
    Voicemails_create = "voicemails_create",
    Voipnumbers = "voipnumbers",
    Voipnumbers_readonly = "voipnumbers_readonly",
    Voipnumbers_update = "voipnumbers_update",
    Voipnumbers_delete = "voipnumbers_delete",
    Voipnumbers_create = "voipnumbers_create",
    Voipnumberavailableforpurchases = "voipnumberavailableforpurchases",
    Voipnumberavailableforpurchases_readonly = "voipnumberavailableforpurchases_readonly",
    Voipnumberavailableforpurchases_update = "voipnumberavailableforpurchases_update",
    Voipnumberavailableforpurchases_delete = "voipnumberavailableforpurchases_delete",
    Voipnumberavailableforpurchases_create = "voipnumberavailableforpurchases_create",
    Voipnumberfaxs = "voipnumberfaxs",
    Voipnumberfaxs_readonly = "voipnumberfaxs_readonly",
    Voipnumberfaxs_update = "voipnumberfaxs_update",
    Voipnumberfaxs_delete = "voipnumberfaxs_delete",
    Voipnumberfaxs_create = "voipnumberfaxs_create",
    Voipnumberphones = "voipnumberphones",
    Voipnumberphones_readonly = "voipnumberphones_readonly",
    Voipnumberphones_update = "voipnumberphones_update",
    Voipnumberphones_delete = "voipnumberphones_delete",
    Voipnumberphones_create = "voipnumberphones_create",
    Webhooks = "webhooks",
    Webhooks_readonly = "webhooks_readonly",
    Webhooks_update = "webhooks_update",
    Webhooks_delete = "webhooks_delete",
    Webhooks_create = "webhooks_create",
    Tags = "tags",
    Tags_readonly = "tags_readonly",
    Tags_update = "tags_update",
    Tags_delete = "tags_delete",
    Tags_create = "tags_create",
    Apikeys = "apikeys",
    Apikeys_readonly = "apikeys_readonly",
    Apikeys_update = "apikeys_update",
    Apikeys_delete = "apikeys_delete",
    Apikeys_create = "apikeys_create",
    Aicalltranscriptions = "aicalltranscriptions",
    Aicalltranscriptions_readonly = "aicalltranscriptions_readonly",
    Aicalltranscriptions_update = "aicalltranscriptions_update",
    Aicalltranscriptions_delete = "aicalltranscriptions_delete",
    Aicalltranscriptions_create = "aicalltranscriptions_create",
    Aicallanalysisinputs = "aicallanalysisinputs",
    Aicallanalysisinputs_readonly = "aicallanalysisinputs_readonly",
    Aicallanalysisinputs_update = "aicallanalysisinputs_update",
    Aicallanalysisinputs_delete = "aicallanalysisinputs_delete",
    Aicallanalysisinputs_create = "aicallanalysisinputs_create",
    Admin = "admin",
    Admin_readonly = "admin_readonly",
    Admin_update = "admin_update",
    Admin_delete = "admin_delete",
    Admin_create = "admin_create",
    Support = "support",
    Support_readonly = "support_readonly",
    Support_update = "support_update",
    Support_delete = "support_delete",
    Support_create = "support_create",
    Wh = "wh",
    Pbx = "pbx",
    Wa = "wa",
    Ws = "ws",
    Root = "root",
}

/** Session is a logged in User (user). We use JWT Security tokens to store this Session. */
export interface UbluxSession {
    /** sub property from JWT. Logged in by what user? This may be a PBX */
    readonly idUser?: string;
    userType?: UserType;
    /** role properties from JWT. Permissions */
    readonly ubluxRoles?: UbluxRole[];
    /** exp property from JWT. Date when session expires */
    readonly expirationDate?: Date;
}

/** Someone that has access to consume Ublux Web Api. It can be a PBX, WA, or Admin. If its a PBX user for example it must point to account tbd 27 */
export interface User {
    /** Id of document */
    readonly id?: string;
    /** Email of user. This is the Id not the email address.
Two users may user the same email address. */
    readonly idEmail?: string;
    /** Key = service/role such as Phone. The phone role probably will have access to the PhoneController service
Value = Permissions it has on that role. Maybe it can only read data from that service but it cannot update, create or modify. */
    ubluxRoles?: UbluxRole[];
    userType?: UserType;
    /** Username needed to authenticate. This is usually an email address in lowercase
If its a PBX/WA then it is the instance id in lowercase */
    readonly username?: string;
    /** Password needed to authenticate. This is different than the Authorization. */
    readonly password?: string;
    /** Ip address where it was last authenticated */
    readonly ipAddressWhereAuthenticated?: string | null;
    /** Date when this user was last authenticated */
    readonly dateAuthenticated?: Date | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for Users */
export interface UserFilterRequest {
    /** IdEmail equals */
    idEmail_eq?: string | null;
    /** IdEmail contains */
    idEmail_con?: string | null;
    /** IdEmail regex */
    idEmail_reg?: string | null;
    ubluxRoles_con?: UbluxRole;
    /** UserType equals */
    userType_eq?: string | null;
    /** UserType contains */
    userType_con?: string | null;
    /** UserType regex */
    userType_reg?: string | null;
    /** Username equals */
    username_eq?: string | null;
    /** Username contains */
    username_con?: string | null;
    /** Username regex */
    username_reg?: string | null;
    /** Password equals */
    password_eq?: string | null;
    /** Password contains */
    password_con?: string | null;
    /** Password regex */
    password_reg?: string | null;
    /** IpAddressWhereAuthenticated equals */
    ipAddressWhereAuthenticated_eq?: string | null;
    /** IpAddressWhereAuthenticated contains */
    ipAddressWhereAuthenticated_con?: string | null;
    /** IpAddressWhereAuthenticated regex */
    ipAddressWhereAuthenticated_reg?: string | null;
    /** DateAuthenticated equals */
    dateAuthenticated_eq?: Date | null;
    /** DateAuthenticated less than or equal to */
    dateAuthenticated_lte?: Date | null;
    /** DateAuthenticated greater than or equal to */
    dateAuthenticated_gte?: Date | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Use flags in case we may need to specify multiple UserTypes */
export enum UserType {
    None = "None",
    Admin = "Admin",
    Support = "Support",
    PBX = "PBX",
    WA = "WA",
    WH = "WH",
    WS = "WS",
}

/** Someone that has access to consume Ublux Web Api. It can be a PBX, WA, or Admin. If its a PBX user for example it must point to account tbd 27 */
export interface UserUpdateRequest {
    /** Key = service/role such as Phone. The phone role probably will have access to the PhoneController service
Value = Permissions it has on that role. Maybe it can only read data from that service but it cannot update, create or modify. */
    ubluxRoles?: UbluxRole[] | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Required to login */
export interface UsernameAndPassword {
    /** This may be the email address or instance id of cloud service */
    username?: string | null;
    /** User password */
    password?: string | null;
}

/** Represents a validation error. */
export interface ValidationError {
    /** Name of property containing error. */
    readonly propertyName?: string | null;
    /** Value of property containing error. */
    readonly propertyValue?: any | null;
    /** Error message */
    readonly errorMessage?: string | null;
}

/** Variable to store custom data about a customer */
export interface Variable {
    /** Name of variable */
    name?: string;
    /** Value of variable. It can be in json or anything */
    value?: string | null;
}

/** Extensions may forward an existing voicemail to another extension */
export interface Voicemail {
    /** Id of document */
    readonly id?: string;
    /** Ids of lines that can listen to voicemail */
    readonly idsLinesThatCanListenToVoicemail?: string[];
    /** Email where voicemail was sent */
    readonly idEmail?: string;
    voicemailType?: VoicemailType;
    /** Voicemail duration in seconds */
    readonly durationInSeconds?: number;
    voicemailWav?: StoredFile;
    voicemailMp3?: StoredFile;
    /** If there is an error sending the voicemail then the error description */
    readonly errorMessage?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for Voicemails */
export interface VoicemailFilterRequest {
    /** IdsLinesThatCanListenToVoicemail equals */
    idsLinesThatCanListenToVoicemail_eq?: string | null;
    /** IdsLinesThatCanListenToVoicemail contains */
    idsLinesThatCanListenToVoicemail_con?: string | null;
    /** IdsLinesThatCanListenToVoicemail regex */
    idsLinesThatCanListenToVoicemail_reg?: string | null;
    /** IdEmail equals */
    idEmail_eq?: string | null;
    /** IdEmail contains */
    idEmail_con?: string | null;
    /** IdEmail regex */
    idEmail_reg?: string | null;
    /** VoicemailType equals */
    voicemailType_eq?: string | null;
    /** VoicemailType contains */
    voicemailType_con?: string | null;
    /** VoicemailType regex */
    voicemailType_reg?: string | null;
    /** VoicemailWav.InstanceId equals */
    voicemailWav_instanceId_eq?: string | null;
    /** VoicemailWav.InstanceId contains */
    voicemailWav_instanceId_con?: string | null;
    /** VoicemailWav.InstanceId regex */
    voicemailWav_instanceId_reg?: string | null;
    /** VoicemailWav.FileSizeInBytes equals */
    voicemailWav_fileSizeInBytes_eq?: number | null;
    /** VoicemailWav.FileSizeInBytes less than or equal to */
    voicemailWav_fileSizeInBytes_lte?: number | null;
    /** VoicemailWav.FileSizeInBytes greater than or equal to */
    voicemailWav_fileSizeInBytes_gte?: number | null;
    /** VoicemailWav.Md5Hash equals */
    voicemailWav_md5Hash_eq?: string | null;
    /** VoicemailWav.Md5Hash contains */
    voicemailWav_md5Hash_con?: string | null;
    /** VoicemailWav.Md5Hash regex */
    voicemailWav_md5Hash_reg?: string | null;
    /** VoicemailWav.Url equals */
    voicemailWav_url_eq?: string | null;
    /** VoicemailWav.Url contains */
    voicemailWav_url_con?: string | null;
    /** VoicemailWav.Url regex */
    voicemailWav_url_reg?: string | null;
    /** VoicemailWav.Id equals */
    voicemailWav_id_eq?: string | null;
    /** VoicemailWav.Id contains */
    voicemailWav_id_con?: string | null;
    /** VoicemailWav.Id regex */
    voicemailWav_id_reg?: string | null;
    /** VoicemailMp3.InstanceId equals */
    voicemailMp3_instanceId_eq?: string | null;
    /** VoicemailMp3.InstanceId contains */
    voicemailMp3_instanceId_con?: string | null;
    /** VoicemailMp3.InstanceId regex */
    voicemailMp3_instanceId_reg?: string | null;
    /** VoicemailMp3.FileSizeInBytes equals */
    voicemailMp3_fileSizeInBytes_eq?: number | null;
    /** VoicemailMp3.FileSizeInBytes less than or equal to */
    voicemailMp3_fileSizeInBytes_lte?: number | null;
    /** VoicemailMp3.FileSizeInBytes greater than or equal to */
    voicemailMp3_fileSizeInBytes_gte?: number | null;
    /** VoicemailMp3.Md5Hash equals */
    voicemailMp3_md5Hash_eq?: string | null;
    /** VoicemailMp3.Md5Hash contains */
    voicemailMp3_md5Hash_con?: string | null;
    /** VoicemailMp3.Md5Hash regex */
    voicemailMp3_md5Hash_reg?: string | null;
    /** VoicemailMp3.Url equals */
    voicemailMp3_url_eq?: string | null;
    /** VoicemailMp3.Url contains */
    voicemailMp3_url_con?: string | null;
    /** VoicemailMp3.Url regex */
    voicemailMp3_url_reg?: string | null;
    /** VoicemailMp3.Id equals */
    voicemailMp3_id_eq?: string | null;
    /** VoicemailMp3.Id contains */
    voicemailMp3_id_con?: string | null;
    /** VoicemailMp3.Id regex */
    voicemailMp3_id_reg?: string | null;
    /** ErrorMessage equals */
    errorMessage_eq?: string | null;
    /** ErrorMessage contains */
    errorMessage_con?: string | null;
    /** ErrorMessage regex */
    errorMessage_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Types of voicemail */
export enum VoicemailType {
    None = "None",
    Regular = "Regular",
    Forwarded = "Forwarded",
}

/** Extensions may forward an existing voicemail to another extension */
export interface VoicemailUpdateRequest {
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Incoming phone number (VoipNumber) */
export interface VoipNumber {
    /** Id of document */
    readonly id?: string;
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** key = id of logic OR id of extension.  
value = day of week when it executes */
    rulesPhone?: RulePhone[];
    /** Incoming SMS will be sent to these email addresses */
    rulesSms?: RuleSms[];
    /** Incoming Faxes will be sent to this email addresses */
    rulesFax?: RuleFax[];
    voipNumberType?: VoipNumberType;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support" 
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Phone number */
    readonly number?: string;
    /** Incoming phone number friendly name */
    friendlyName?: string;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** City of incoming phone number */
    readonly city?: string;
    /** State of incoming phone number */
    readonly state?: string;
    countryIsoCode?: CountryIsoCode;
    /** Does this phone number have SMS capabilities? */
    readonly isSmsEnabled?: boolean;
    /** Does this phone number have calling capabilities? */
    readonly isVoiceEnabled?: boolean;
    /** Is this phone number toll free? */
    readonly isTollFree?: boolean;
    /** TimeZone of this phone number */
    timeZone?: string;
    /** Beause a lot of collections depend on a number instead of deleting it we mark it as disconnected. */
    readonly isDisconnected?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Incoming phone number available for purchase */
export interface VoipNumberAvailableForPurchase {
    /** Id of document */
    readonly id?: string;
    /** key = id of logic OR id of extension.  
value = day of week when it executes */
    readonly rulesPhone?: RulePhone[];
    /** Incoming SMS will be sent to these email addresses */
    readonly rulesSms?: RuleSms[];
    /** Incoming Faxes will be sent to this email addresses */
    readonly rulesFax?: RuleFax[];
    /** Requires customer info in order to be purchased */
    readonly requiresCustomerInfo?: boolean;
    voipNumberType?: VoipNumberType;
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support" 
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Phone number */
    readonly number?: string;
    /** Incoming phone number friendly name */
    friendlyName?: string;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** City of incoming phone number */
    readonly city?: string;
    /** State of incoming phone number */
    readonly state?: string;
    countryIsoCode?: CountryIsoCode;
    /** Does this phone number have SMS capabilities? */
    readonly isSmsEnabled?: boolean;
    /** Does this phone number have calling capabilities? */
    readonly isVoiceEnabled?: boolean;
    /** Is this phone number toll free? */
    readonly isTollFree?: boolean;
    /** TimeZone of this phone number */
    timeZone?: string;
    /** Beause a lot of collections depend on a number instead of deleting it we mark it as disconnected. */
    readonly isDisconnected?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for VoipNumberAvailableForPurchases */
export interface VoipNumberAvailableForPurchaseFilterRequest {
    /** RulesPhone.IdCallFlowLogic equals */
    rulesPhone_idCallFlowLogic_eq?: string | null;
    /** RulesPhone.IdCallFlowLogic contains */
    rulesPhone_idCallFlowLogic_con?: string | null;
    /** RulesPhone.IdCallFlowLogic regex */
    rulesPhone_idCallFlowLogic_reg?: string | null;
    /** RulesPhone.IdExtension equals */
    rulesPhone_idExtension_eq?: string | null;
    /** RulesPhone.IdExtension contains */
    rulesPhone_idExtension_con?: string | null;
    /** RulesPhone.IdExtension regex */
    rulesPhone_idExtension_reg?: string | null;
    rulesPhone_daysOfWeek_con?: DayOfWeek;
    /** RulesSms.IdEmail equals */
    rulesSms_idEmail_eq?: string | null;
    /** RulesSms.IdEmail contains */
    rulesSms_idEmail_con?: string | null;
    /** RulesSms.IdEmail regex */
    rulesSms_idEmail_reg?: string | null;
    /** RulesFax.IdEmail equals */
    rulesFax_idEmail_eq?: string | null;
    /** RulesFax.IdEmail contains */
    rulesFax_idEmail_con?: string | null;
    /** RulesFax.IdEmail regex */
    rulesFax_idEmail_reg?: string | null;
    /** RequiresCustomerInfo equals */
    requiresCustomerInfo_eq?: boolean | null;
    /** VoipNumberType equals */
    voipNumberType_eq?: string | null;
    /** VoipNumberType contains */
    voipNumberType_con?: string | null;
    /** VoipNumberType regex */
    voipNumberType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** InjectFriendlyNameToCallerId equals */
    injectFriendlyNameToCallerId_eq?: boolean | null;
    /** RecordIncomingCalls equals */
    recordIncomingCalls_eq?: boolean | null;
    /** UseAiForIncomingCalls equals */
    useAiForIncomingCalls_eq?: boolean | null;
    /** IdAiCallAnalysisInput equals */
    idAiCallAnalysisInput_eq?: string | null;
    /** IdAiCallAnalysisInput contains */
    idAiCallAnalysisInput_con?: string | null;
    /** IdAiCallAnalysisInput regex */
    idAiCallAnalysisInput_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Language equals */
    language_eq?: string | null;
    /** Language contains */
    language_con?: string | null;
    /** Language regex */
    language_reg?: string | null;
    /** City equals */
    city_eq?: string | null;
    /** City contains */
    city_con?: string | null;
    /** City regex */
    city_reg?: string | null;
    /** State equals */
    state_eq?: string | null;
    /** State contains */
    state_con?: string | null;
    /** State regex */
    state_reg?: string | null;
    /** CountryIsoCode equals */
    countryIsoCode_eq?: string | null;
    /** CountryIsoCode contains */
    countryIsoCode_con?: string | null;
    /** CountryIsoCode regex */
    countryIsoCode_reg?: string | null;
    /** IsSmsEnabled equals */
    isSmsEnabled_eq?: boolean | null;
    /** IsVoiceEnabled equals */
    isVoiceEnabled_eq?: boolean | null;
    /** IsTollFree equals */
    isTollFree_eq?: boolean | null;
    /** TimeZone equals */
    timeZone_eq?: string | null;
    /** TimeZone contains */
    timeZone_con?: string | null;
    /** TimeZone regex */
    timeZone_reg?: string | null;
    /** IsDisconnected equals */
    isDisconnected_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Incoming phone number available for purchase */
export interface VoipNumberAvailableForPurchaseUpdateRequest {
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support"
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean | null;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean | null;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean | null;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Incoming phone number friendly name */
    friendlyName?: string | null;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** TimeZone of this phone number */
    timeZone?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Incoming phone number configured to receive faxes */
export interface VoipNumberFax {
    /** Id of document */
    readonly id?: string;
    /** key = id of logic OR id of extension.  
value = day of week when it executes */
    rulesPhone?: RulePhone[];
    /** Incoming SMS will be sent to these email addresses */
    rulesSms?: RuleSms[];
    /** Incoming Faxes will be sent to this email addresses */
    rulesFax?: RuleFax[];
    voipNumberType?: VoipNumberType;
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support" 
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Phone number */
    readonly number?: string;
    /** Incoming phone number friendly name */
    friendlyName?: string;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** City of incoming phone number */
    readonly city?: string;
    /** State of incoming phone number */
    readonly state?: string;
    countryIsoCode?: CountryIsoCode;
    /** Does this phone number have SMS capabilities? */
    readonly isSmsEnabled?: boolean;
    /** Does this phone number have calling capabilities? */
    readonly isVoiceEnabled?: boolean;
    /** Is this phone number toll free? */
    readonly isTollFree?: boolean;
    /** TimeZone of this phone number */
    timeZone?: string;
    /** Beause a lot of collections depend on a number instead of deleting it we mark it as disconnected. */
    readonly isDisconnected?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for VoipNumberFaxs */
export interface VoipNumberFaxFilterRequest {
    /** RulesPhone.IdCallFlowLogic equals */
    rulesPhone_idCallFlowLogic_eq?: string | null;
    /** RulesPhone.IdCallFlowLogic contains */
    rulesPhone_idCallFlowLogic_con?: string | null;
    /** RulesPhone.IdCallFlowLogic regex */
    rulesPhone_idCallFlowLogic_reg?: string | null;
    /** RulesPhone.IdExtension equals */
    rulesPhone_idExtension_eq?: string | null;
    /** RulesPhone.IdExtension contains */
    rulesPhone_idExtension_con?: string | null;
    /** RulesPhone.IdExtension regex */
    rulesPhone_idExtension_reg?: string | null;
    rulesPhone_daysOfWeek_con?: DayOfWeek;
    /** RulesSms.IdEmail equals */
    rulesSms_idEmail_eq?: string | null;
    /** RulesSms.IdEmail contains */
    rulesSms_idEmail_con?: string | null;
    /** RulesSms.IdEmail regex */
    rulesSms_idEmail_reg?: string | null;
    /** RulesFax.IdEmail equals */
    rulesFax_idEmail_eq?: string | null;
    /** RulesFax.IdEmail contains */
    rulesFax_idEmail_con?: string | null;
    /** RulesFax.IdEmail regex */
    rulesFax_idEmail_reg?: string | null;
    /** VoipNumberType equals */
    voipNumberType_eq?: string | null;
    /** VoipNumberType contains */
    voipNumberType_con?: string | null;
    /** VoipNumberType regex */
    voipNumberType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** InjectFriendlyNameToCallerId equals */
    injectFriendlyNameToCallerId_eq?: boolean | null;
    /** RecordIncomingCalls equals */
    recordIncomingCalls_eq?: boolean | null;
    /** UseAiForIncomingCalls equals */
    useAiForIncomingCalls_eq?: boolean | null;
    /** IdAiCallAnalysisInput equals */
    idAiCallAnalysisInput_eq?: string | null;
    /** IdAiCallAnalysisInput contains */
    idAiCallAnalysisInput_con?: string | null;
    /** IdAiCallAnalysisInput regex */
    idAiCallAnalysisInput_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Language equals */
    language_eq?: string | null;
    /** Language contains */
    language_con?: string | null;
    /** Language regex */
    language_reg?: string | null;
    /** City equals */
    city_eq?: string | null;
    /** City contains */
    city_con?: string | null;
    /** City regex */
    city_reg?: string | null;
    /** State equals */
    state_eq?: string | null;
    /** State contains */
    state_con?: string | null;
    /** State regex */
    state_reg?: string | null;
    /** CountryIsoCode equals */
    countryIsoCode_eq?: string | null;
    /** CountryIsoCode contains */
    countryIsoCode_con?: string | null;
    /** CountryIsoCode regex */
    countryIsoCode_reg?: string | null;
    /** IsSmsEnabled equals */
    isSmsEnabled_eq?: boolean | null;
    /** IsVoiceEnabled equals */
    isVoiceEnabled_eq?: boolean | null;
    /** IsTollFree equals */
    isTollFree_eq?: boolean | null;
    /** TimeZone equals */
    timeZone_eq?: string | null;
    /** TimeZone contains */
    timeZone_con?: string | null;
    /** TimeZone regex */
    timeZone_reg?: string | null;
    /** IsDisconnected equals */
    isDisconnected_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Incoming phone number configured to receive faxes */
export interface VoipNumberFaxUpdateRequest {
    /** key = id of logic OR id of extension.
value = day of week when it executes */
    rulesPhone?: RulePhone[] | null;
    /** Incoming SMS will be sent to these email addresses */
    rulesSms?: RuleSms[] | null;
    /** Incoming Faxes will be sent to this email addresses */
    rulesFax?: RuleFax[] | null;
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support"
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean | null;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean | null;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean | null;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Incoming phone number friendly name */
    friendlyName?: string | null;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** TimeZone of this phone number */
    timeZone?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Enables searching for VoipNumbers */
export interface VoipNumberFilterRequest {
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** RulesPhone.IdCallFlowLogic equals */
    rulesPhone_idCallFlowLogic_eq?: string | null;
    /** RulesPhone.IdCallFlowLogic contains */
    rulesPhone_idCallFlowLogic_con?: string | null;
    /** RulesPhone.IdCallFlowLogic regex */
    rulesPhone_idCallFlowLogic_reg?: string | null;
    /** RulesPhone.IdExtension equals */
    rulesPhone_idExtension_eq?: string | null;
    /** RulesPhone.IdExtension contains */
    rulesPhone_idExtension_con?: string | null;
    /** RulesPhone.IdExtension regex */
    rulesPhone_idExtension_reg?: string | null;
    rulesPhone_daysOfWeek_con?: DayOfWeek;
    /** RulesSms.IdEmail equals */
    rulesSms_idEmail_eq?: string | null;
    /** RulesSms.IdEmail contains */
    rulesSms_idEmail_con?: string | null;
    /** RulesSms.IdEmail regex */
    rulesSms_idEmail_reg?: string | null;
    /** RulesFax.IdEmail equals */
    rulesFax_idEmail_eq?: string | null;
    /** RulesFax.IdEmail contains */
    rulesFax_idEmail_con?: string | null;
    /** RulesFax.IdEmail regex */
    rulesFax_idEmail_reg?: string | null;
    /** VoipNumberType equals */
    voipNumberType_eq?: string | null;
    /** VoipNumberType contains */
    voipNumberType_con?: string | null;
    /** VoipNumberType regex */
    voipNumberType_reg?: string | null;
    /** InjectFriendlyNameToCallerId equals */
    injectFriendlyNameToCallerId_eq?: boolean | null;
    /** RecordIncomingCalls equals */
    recordIncomingCalls_eq?: boolean | null;
    /** UseAiForIncomingCalls equals */
    useAiForIncomingCalls_eq?: boolean | null;
    /** IdAiCallAnalysisInput equals */
    idAiCallAnalysisInput_eq?: string | null;
    /** IdAiCallAnalysisInput contains */
    idAiCallAnalysisInput_con?: string | null;
    /** IdAiCallAnalysisInput regex */
    idAiCallAnalysisInput_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Language equals */
    language_eq?: string | null;
    /** Language contains */
    language_con?: string | null;
    /** Language regex */
    language_reg?: string | null;
    /** City equals */
    city_eq?: string | null;
    /** City contains */
    city_con?: string | null;
    /** City regex */
    city_reg?: string | null;
    /** State equals */
    state_eq?: string | null;
    /** State contains */
    state_con?: string | null;
    /** State regex */
    state_reg?: string | null;
    /** CountryIsoCode equals */
    countryIsoCode_eq?: string | null;
    /** CountryIsoCode contains */
    countryIsoCode_con?: string | null;
    /** CountryIsoCode regex */
    countryIsoCode_reg?: string | null;
    /** IsSmsEnabled equals */
    isSmsEnabled_eq?: boolean | null;
    /** IsVoiceEnabled equals */
    isVoiceEnabled_eq?: boolean | null;
    /** IsTollFree equals */
    isTollFree_eq?: boolean | null;
    /** TimeZone equals */
    timeZone_eq?: string | null;
    /** TimeZone contains */
    timeZone_con?: string | null;
    /** TimeZone regex */
    timeZone_reg?: string | null;
    /** IsDisconnected equals */
    isDisconnected_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Incoming phone number configured to receive phone calls */
export interface VoipNumberPhone {
    /** Id of document */
    readonly id?: string;
    /** key = id of logic OR id of extension.  
value = day of week when it executes */
    rulesPhone?: RulePhone[];
    /** Incoming SMS will be sent to these email addresses */
    rulesSms?: RuleSms[];
    /** Incoming Faxes will be sent to this email addresses */
    rulesFax?: RuleFax[];
    voipNumberType?: VoipNumberType;
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support" 
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Phone number */
    readonly number?: string;
    /** Incoming phone number friendly name */
    friendlyName?: string;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** City of incoming phone number */
    readonly city?: string;
    /** State of incoming phone number */
    readonly state?: string;
    countryIsoCode?: CountryIsoCode;
    /** Does this phone number have SMS capabilities? */
    readonly isSmsEnabled?: boolean;
    /** Does this phone number have calling capabilities? */
    readonly isVoiceEnabled?: boolean;
    /** Is this phone number toll free? */
    readonly isTollFree?: boolean;
    /** TimeZone of this phone number */
    timeZone?: string;
    /** Beause a lot of collections depend on a number instead of deleting it we mark it as disconnected. */
    readonly isDisconnected?: boolean;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for VoipNumberPhones */
export interface VoipNumberPhoneFilterRequest {
    /** RulesPhone.IdCallFlowLogic equals */
    rulesPhone_idCallFlowLogic_eq?: string | null;
    /** RulesPhone.IdCallFlowLogic contains */
    rulesPhone_idCallFlowLogic_con?: string | null;
    /** RulesPhone.IdCallFlowLogic regex */
    rulesPhone_idCallFlowLogic_reg?: string | null;
    /** RulesPhone.IdExtension equals */
    rulesPhone_idExtension_eq?: string | null;
    /** RulesPhone.IdExtension contains */
    rulesPhone_idExtension_con?: string | null;
    /** RulesPhone.IdExtension regex */
    rulesPhone_idExtension_reg?: string | null;
    rulesPhone_daysOfWeek_con?: DayOfWeek;
    /** RulesSms.IdEmail equals */
    rulesSms_idEmail_eq?: string | null;
    /** RulesSms.IdEmail contains */
    rulesSms_idEmail_con?: string | null;
    /** RulesSms.IdEmail regex */
    rulesSms_idEmail_reg?: string | null;
    /** RulesFax.IdEmail equals */
    rulesFax_idEmail_eq?: string | null;
    /** RulesFax.IdEmail contains */
    rulesFax_idEmail_con?: string | null;
    /** RulesFax.IdEmail regex */
    rulesFax_idEmail_reg?: string | null;
    /** VoipNumberType equals */
    voipNumberType_eq?: string | null;
    /** VoipNumberType contains */
    voipNumberType_con?: string | null;
    /** VoipNumberType regex */
    voipNumberType_reg?: string | null;
    /** IdMusicOnHoldGroup equals */
    idMusicOnHoldGroup_eq?: string | null;
    /** IdMusicOnHoldGroup contains */
    idMusicOnHoldGroup_con?: string | null;
    /** IdMusicOnHoldGroup regex */
    idMusicOnHoldGroup_reg?: string | null;
    /** InjectFriendlyNameToCallerId equals */
    injectFriendlyNameToCallerId_eq?: boolean | null;
    /** RecordIncomingCalls equals */
    recordIncomingCalls_eq?: boolean | null;
    /** UseAiForIncomingCalls equals */
    useAiForIncomingCalls_eq?: boolean | null;
    /** IdAiCallAnalysisInput equals */
    idAiCallAnalysisInput_eq?: string | null;
    /** IdAiCallAnalysisInput contains */
    idAiCallAnalysisInput_con?: string | null;
    /** IdAiCallAnalysisInput regex */
    idAiCallAnalysisInput_reg?: string | null;
    /** Number equals */
    number_eq?: string | null;
    /** Number contains */
    number_con?: string | null;
    /** Number regex */
    number_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** Language equals */
    language_eq?: string | null;
    /** Language contains */
    language_con?: string | null;
    /** Language regex */
    language_reg?: string | null;
    /** City equals */
    city_eq?: string | null;
    /** City contains */
    city_con?: string | null;
    /** City regex */
    city_reg?: string | null;
    /** State equals */
    state_eq?: string | null;
    /** State contains */
    state_con?: string | null;
    /** State regex */
    state_reg?: string | null;
    /** CountryIsoCode equals */
    countryIsoCode_eq?: string | null;
    /** CountryIsoCode contains */
    countryIsoCode_con?: string | null;
    /** CountryIsoCode regex */
    countryIsoCode_reg?: string | null;
    /** IsSmsEnabled equals */
    isSmsEnabled_eq?: boolean | null;
    /** IsVoiceEnabled equals */
    isVoiceEnabled_eq?: boolean | null;
    /** IsTollFree equals */
    isTollFree_eq?: boolean | null;
    /** TimeZone equals */
    timeZone_eq?: string | null;
    /** TimeZone contains */
    timeZone_con?: string | null;
    /** TimeZone regex */
    timeZone_reg?: string | null;
    /** IsDisconnected equals */
    isDisconnected_eq?: boolean | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Incoming phone number configured to receive phone calls */
export interface VoipNumberPhoneUpdateRequest {
    /** key = id of logic OR id of extension.
value = day of week when it executes */
    rulesPhone?: RulePhone[] | null;
    /** Incoming SMS will be sent to these email addresses */
    rulesSms?: RuleSms[] | null;
    /** Incoming Faxes will be sent to this email addresses */
    rulesFax?: RuleFax[] | null;
    /** Music on hold to use for outgoing calls to PSTN only */
    idMusicOnHoldGroup?: string | null;
    /** This is only for external incoming calls
If the friendly name of this VoipNumber is "Spanish Support" then "Spanish Support"
will be injected to the caller id allowing the agent to know that she has to answer in Spanish for example */
    injectFriendlyNameToCallerId?: boolean | null;
    /** Record incoming phone calls received by this phone number? */
    recordIncomingCalls?: boolean | null;
    /** Users will be charged extra for AI transcriptions. If this is true call will be recorded in order to do AI work */
    useAiForIncomingCalls?: boolean | null;
    /** What input to pass to AI engine in case UseAiForIncomingCalls=true. If null it should use a default input that is part of constants. */
    idAiCallAnalysisInput?: string | null;
    /** Incoming phone number friendly name */
    friendlyName?: string | null;
    /** Incoming phone number description */
    description?: string | null;
    language?: Language;
    /** TimeZone of this phone number */
    timeZone?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

/** Type of DIDs */
export enum VoipNumberType {
    None = "None",
    Phone = "Phone",
    Fax = "Fax",
    AvailableForPurchase = "AvailableForPurchase",
}

/** Web callback that will be fired when a custom event of interest occurs. */
export interface WebHook {
    /** Id of document */
    readonly id?: string;
    eventTriggerType?: EventTriggerType;
    /** Friendly name of webhook */
    friendlyName?: string;
    /** Url where event will be sent
TODO: place index on this field. Index is needed because when zapier deletes/unsubscribes it passes this url */
    url?: string;
    /** Custom headers to inject on request. Example: x-token:1234,user:user1 */
    headers?: string[];
    /** Description of webhook */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account. 
For example a CloudService user will point to no account */
    idsTags?: string[];
    /** Creation date. Sets DateUpdated if it does not have a value */
    readonly dateCreated?: Date;
    /** Updated date. When item is created on database this date will be set too. This is important so that we can sync contacts */
    readonly dateUpdated?: Date;
}

/** Enables searching for WebHooks */
export interface WebHookFilterRequest {
    /** EventTriggerType equals */
    eventTriggerType_eq?: string | null;
    /** EventTriggerType contains */
    eventTriggerType_con?: string | null;
    /** EventTriggerType regex */
    eventTriggerType_reg?: string | null;
    /** FriendlyName equals */
    friendlyName_eq?: string | null;
    /** FriendlyName contains */
    friendlyName_con?: string | null;
    /** FriendlyName regex */
    friendlyName_reg?: string | null;
    /** Url equals */
    url_eq?: string | null;
    /** Url contains */
    url_con?: string | null;
    /** Url regex */
    url_reg?: string | null;
    /** Headers equals */
    headers_eq?: string | null;
    /** Headers contains */
    headers_con?: string | null;
    /** Headers regex */
    headers_reg?: string | null;
    /** Description equals */
    description_eq?: string | null;
    /** Description contains */
    description_con?: string | null;
    /** Description regex */
    description_reg?: string | null;
    /** IdsTags equals */
    idsTags_eq?: string | null;
    /** IdsTags contains */
    idsTags_con?: string | null;
    /** IdsTags regex */
    idsTags_reg?: string | null;
    /** Id equals */
    id_eq?: string | null;
    /** Id contains */
    id_con?: string | null;
    /** Id regex */
    id_reg?: string | null;
    /** DateCreated equals */
    dateCreated_eq?: Date | null;
    /** DateCreated less than or equal to */
    dateCreated_lte?: Date | null;
    /** DateCreated greater than or equal to */
    dateCreated_gte?: Date | null;
    /** DateUpdated equals */
    dateUpdated_eq?: Date | null;
    /** DateUpdated less than or equal to */
    dateUpdated_lte?: Date | null;
    /** DateUpdated greater than or equal to */
    dateUpdated_gte?: Date | null;
}

/** Web callback that will be fired when a custom event of interest occurs. */
export interface WebHookUpdateRequest {
    eventTriggerType?: EventTriggerType;
    /** Friendly name of webhook */
    friendlyName?: string | null;
    /** Url where event will be sent
TODO: place index on this field. Index is needed because when zapier deletes/unsubscribes it passes this url */
    url?: string | null;
    /** Custom headers to inject on request. Example: x-token:1234,user:user1 */
    headers?: string[] | null;
    /** Description of webhook */
    description?: string | null;
    /** It is nullable because there are cases where it makes no sense to point to an account.
For example a CloudService user will point to no account */
    idsTags?: string[] | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}